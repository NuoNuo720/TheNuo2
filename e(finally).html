<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>自由电子冒险 | Electron Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- 配置Tailwind自定义主题 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',    // 电子蓝
                        secondary: '#F97316',  // 质子橙
                        neutral: '#1E293B',    // 背景深蓝
                        field: '#10B981',      // 电场绿
                        danger: '#EF4444',     // 危险红
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .electron-glow {
                box-shadow: 0 0 15px 5px rgba(59, 130, 246, 0.6);
            }
            .proton-glow {
                box-shadow: 0 0 15px 5px rgba(249, 115, 22, 0.6);
            }
            .field-glow {
                box-shadow: 0 0 10px 2px rgba(16, 185, 129, 0.5);
            }
            .game-container {
                perspective: 1000px;
            }
            .sr-only {
                position: absolute;
                width: 1px;
                height: 1px;
                padding: 0;
                margin: -1px;
                overflow: hidden;
                clip: rect(0, 0, 0, 0);
                white-space: nowrap;
                border-width: 0;
            }
            .animate-slide-in {
                animation: slideIn 0.3s ease-out forwards;
            }
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .floating {
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes spin-slow {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .spin-slow {
            animation: spin-slow 10s linear infinite;
        }
        
        .trap-pulse {
            animation: trapPulse 2s infinite;
        }
        
        @keyframes trapPulse {
            0%, 100% { box-shadow: 0 0 10px 2px rgba(239, 68, 68, 0.5); }
            50% { box-shadow: 0 0 15px 5px rgba(239, 68, 68, 0.8); }
        }

        /* 响应式调整 */
        @media (max-width: 640px) {
            .control-btn {
                padding: 4vw 6vw !important;
            }
            
            .control-icon {
                font-size: 6vw !important;
            }
            
            .status-panel {
                font-size: 3.5vw !important;
                padding: 2vw !important;
            }
        }
        .back-container {
            position: fixed; /* 固定在视窗底部 */
            bottom: 30px; /* 距离底部30px */
            left: 50%; /* 水平居中 */
            transform: translateX(-50%); /* 精确居中 */
        }

    </style>
</head>
<body class="bg-gradient-to-br from-neutral to-slate-900 text-white min-h-screen font-sans overflow-x-hidden">
    <!-- 屏幕阅读器状态通知 -->
    <div aria-live="polite" class="sr-only" id="statusAnnouncer"></div>
    
    <!-- 游戏容器 -->
    <div class="container mx-auto px-3 py-4 max-w-6xl">
        <!-- 游戏标题 -->
        <header class="mb-4 text-center">
            <h1 class="text-[clamp(1.5rem,5vw,2.5rem)] font-bold mb-2 bg-clip-text text-transparent bg-gradient-to-r from-primary to-blue-400">
                自由电子冒险
            </h1>
            <p class="text-blue-300 text-sm md:text-base">引导电子穿越电场，修复能量系统！</p>
        </header>
        
        <!-- 游戏状态面板 -->
        <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
            <div class="bg-slate-800/70 backdrop-blur-sm rounded-lg p-2 flex items-center status-panel">
                <i class="fa fa-bolt text-yellow-400 mr-2"></i>
                <span>修复阶段: <span id="level" class="font-bold">1</span></span>
            </div>
            <div class="bg-slate-800/70 backdrop-blur-sm rounded-lg p-2 flex items-center status-panel">
                <i class="fa fa-star text-yellow-500 mr-2"></i>
                <span>系统能量: <span id="score" class="font-bold">0</span></span>
            </div>
            <div class="bg-slate-800/70 backdrop-blur-sm rounded-lg p-2 flex items-center status-panel">
                <i class="fa fa-clock-o text-green-400 mr-2"></i>
                <span>剩余时间: <span id="timer" class="font-bold">30</span>s</span>
            </div>
            <button id="restartBtn" class="bg-primary hover:bg-primary/80 transition-colors px-3 py-2 rounded-lg flex items-center text-sm" aria-label="重启当前关卡">
                <i class="fa fa-refresh mr-1"></i> 重启系统
            </button>
        </div>
        <!-- 排行榜按钮 -->
        <div class="flex justify-center mb-3">
            <button id="rankingBtn" class="bg-yellow-500 hover:bg-yellow-600 text-neutral transition-colors px-3 py-2 rounded-lg flex items-center text-sm">
                <i class="fa fa-trophy mr-1"></i> 查看排行榜
            </button>
        </div>

        <!-- 排行榜弹窗 -->
        <div id="rankingModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-slate-800 rounded-xl p-6 max-w-md w-11/12 mx-4 transform transition-all">
                <h2 class="text-xl font-bold mb-4 text-center text-yellow-400">
                    <i class="fa fa-trophy mr-2"></i>能量修复排行榜
                </h2>
                <div id="rankingList" class="max-h-60 overflow-y-auto mb-5 space-y-2">
                    <!-- 排行榜数据将通过JS动态插入 -->
                </div>
                <div class="flex justify-center">
                    <button id="closeRankingBtn" class="bg-primary hover:bg-primary/80 transition-colors px-5 py-2 rounded-lg text-sm">
                        关闭
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 成就通知容器 -->
        <div id="achievementContainer" class="fixed top-4 right-4 z-50 flex flex-col gap-2 max-w-xs"></div>
        
        <!-- 游戏区域 - 自适应高度 -->
        <div id="gameArea" class="game-container relative bg-slate-900/60 backdrop-blur-sm rounded-xl overflow-hidden border-2 border-slate-700 mb-4 transition-opacity duration-500" style="height: clamp(300px, 50vh, 500px);">
            <!-- 电子 -->
            <div id="electron" class="absolute w-8 h-8 bg-primary rounded-full electron-glow floating" style="left: 50px; top: 50%;">
                <div class="absolute -inset-1 bg-gradient-to-r from-primary to-blue-300 rounded-full opacity-30"></div>
                <div class="absolute inset-0 flex items-center justify-center text-white text-xs font-bold">e⁻</div>
            </div>
            
            <!-- 目标位置 -->
            <div id="target" class="absolute w-12 h-12 border-2 border-dashed border-green-400 rounded-full flex items-center justify-center" style="left: 80%; top: 50%;">
                <div class="w-4 h-4 bg-green-400 rounded-full"></div>
            </div>
        </div>
        
        <!-- 控制面板 - 自适应按钮大小 -->
        <div class="bg-slate-800/70 backdrop-blur-sm rounded-lg p-3 mb-4">
            <h3 class="text-center text-base font-semibold mb-2">电场控制中心</h3>
            <div class="flex justify-center gap-3 md:gap-6 flex-wrap">
                <button id="leftFieldBtn" class="bg-slate-700 hover:bg-slate-600 transition-all px-6 py-3 rounded-lg field-glow flex flex-col items-center control-btn" aria-label="应用左电场，电子向右移动">
                    <i class="fa fa-arrow-left text-field text-2xl mb-1 control-icon"></i>
                    <span>左电场</span>
                </button>
                <button id="rightFieldBtn" class="bg-slate-700 hover:bg-slate-600 transition-all px-6 py-3 rounded-lg field-glow flex flex-col items-center control-btn" aria-label="应用右电场，电子向左移动">
                    <i class="fa fa-arrow-right text-field text-2xl mb-1 control-icon"></i>
                    <span>右电场</span>
                </button>
                <button id="upFieldBtn" class="bg-slate-700 hover:bg-slate-600 transition-all px-6 py-3 rounded-lg field-glow flex flex-col items-center control-btn" aria-label="应用上电场，电子向下移动">
                    <i class="fa fa-arrow-up text-field text-2xl mb-1 control-icon"></i>
                    <span>上电场</span>
                </button>
                <button id="downFieldBtn" class="bg-slate-700 hover:bg-slate-600 transition-all px-6 py-3 rounded-lg field-glow flex flex-col items-center control-btn" aria-label="应用下电场，电子向上移动">
                    <i class="fa fa-arrow-down text-field text-2xl mb-1 control-icon"></i>
                    <span>下电场</span>
                </button>
            </div>
            <p class="text-center text-xs text-slate-400 mt-3">提示: 电子带负电，会向电场相反方向移动</p>
        </div>
        
        <!-- 游戏消息弹窗 -->
        <div id="messageModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 hidden">
            <div class="bg-slate-800 rounded-xl p-6 max-w-md w-11/12 mx-4 transform transition-all">
                <h2 id="modalTitle" class="text-xl font-bold mb-3 text-center"></h2>
                <p id="modalMessage" class="text-center mb-5 text-sm"></p>
                <div class="flex justify-center">
                    <button id="modalBtn" class="bg-primary hover:bg-primary/80 transition-colors px-5 py-2 rounded-lg text-sm">
                        继续
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 移动设备虚拟摇杆 -->
    <div id="virtualJoystick" class="fixed bottom-20 left-6 w-24 h-24 bg-slate-800/50 rounded-full backdrop-blur-sm z-40 hidden">
        <div id="joystickHandle" class="absolute w-12 h-12 bg-primary rounded-full electron-glow left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2"></div>
    </div>
    
    <script>
        // 游戏状态变量
        const gameState = {
            electron: {
                element: null,
                x: 50,
                y: 0,
                velocityX: 0,
                velocityY: 0,
                speed: 3,
                size: 32
            },
            target: {
                x: 0,
                y: 0,
                element: null,
                size: 48
            },
            fieldButtons: [],
            obstacles: [],
            protons: [],
            traps: [],
            level: 1,
            score: 0,
            timeLeft: 30,
            timerInterval: null,
            moves: 0,
            gameArea: null,
            gameWidth: 0,
            gameHeight: 0,
            isPlaying: false,
            gameLoop: null,
            minObstacleDistance: 80,
            baseObstacleSize: 36,
            consecutiveLevels: 0, // 连续完成的关卡数，用于成就系统
            currentLevelTime: 0,  // 当前关卡用时
            levelStartTime: 0     // 关卡开始时间
        };
        
        // 成就系统
        const achievements = {
            list: [
                { id: 'first_win', name: '初次成功', description: '完成第一关', completed: false, points: 100 },
                { id: 'speed_run', name: '闪电速度', description: '10秒内完成一关', completed: false, points: 200 },
                { id: 'perfect', name: '完美操作', description: '用少于5步完成关卡', completed: false, points: 150 },
                { id: 'survivor', name: '生存大师', description: '连续完成5关', completed: false, points: 300 }
            ],
            
            checkConditions(levelStats) {
                // 检查各项成就条件
                if (levelStats.level === 1 && levelStats.success) {
                    this.unlock('first_win');
                }
                
                if (levelStats.timeTaken < 10 && levelStats.success) {
                    this.unlock('speed_run');
                }
                
                if (levelStats.moves < 5 && levelStats.success) {
                    this.unlock('perfect');
                }
                
                if (levelStats.consecutiveLevels >= 5 && levelStats.success) {
                    this.unlock('survivor');
                }
            },
            
            unlock(id) {
                const achievement = this.list.find(a => a.id === id);
                if (achievement && !achievement.completed) {
                    achievement.completed = true;
                    gameState.score += achievement.points;
                    elements.scoreDisplay.textContent = gameState.score;
                    this.showNotification(achievement);
                    this.save();
                    announceStatus(`解锁成就: ${achievement.name}，获得${achievement.points}分`);
                }
            },
            
            showNotification(achievement) {
                const container = document.getElementById('achievementContainer');
                const notification = document.createElement('div');
                notification.className = 'bg-green-500 text-white p-3 rounded-lg animate-slide-in shadow-lg';
                notification.innerHTML = `
                    <h3 class="font-bold">解锁成就: ${achievement.name}</h3>
                    <p class="text-sm">${achievement.description} +${achievement.points}分</p>
                `;
                container.appendChild(notification);
                
                setTimeout(() => {
                    notification.classList.add('opacity-0', 'transition-opacity', 'duration-500');
                    setTimeout(() => notification.remove(), 500);
                }, 3000);
            },
            
            save() {
                try {
                    localStorage.setItem('electronAdventureAchievements', JSON.stringify(this.list));
                } catch (e) {
                    console.error('无法保存成就:', e);
                }
            },
            
            load() {
                try {
                    const saved = localStorage.getItem('electronAdventureAchievements');
                    if (saved) this.list = JSON.parse(saved);
                } catch (e) {
                    console.error('无法加载成就:', e);
                }
            }
        };
        
        // 排行榜相关函数
        const rankingSystem = {
            // 初始化排行榜（增加存储检测）
            init() {
                try {
                    // 测试localStorage是否可用
                    const testKey = 'test_' + Date.now();
                    localStorage.setItem(testKey, 'test');
                    localStorage.removeItem(testKey);
                    
                    const savedRankings = localStorage.getItem('electronAdventureRankings');
                    if (savedRankings) {
                        this.rankings = JSON.parse(savedRankings);
                    } else {
                        // 初始化默认数据
                        this.rankings = [
                            { name: '玩家1', score: 1500, date: this.formatDate(new Date()) },
                            { name: '玩家2', score: 1200, date: this.formatDate(new Date()) },
                            { name: '玩家3', score: 900, date: this.formatDate(new Date()) },
                            { name: '玩家4', score: 700, date: this.formatDate(new Date()) },
                            { name: '玩家5', score: 500, date: this.formatDate(new Date()) }
                        ];
                        this.save();
                    }
                } catch (e) {
                    // 存储不可用时使用内存存储
                    this.rankings = [
                        { name: '玩家1', score: 1500, date: this.formatDate(new Date()) },
                        { name: '玩家2', score: 1200, date: this.formatDate(new Date()) },
                        { name: '玩家3', score: 900, date: this.formatDate(new Date()) }
                    ];
                    console.log('本地存储不可用，使用临时存储:', e);
                }
            },

            // 保存数据（增加错误处理）
            save() {
                try {
                    if (typeof localStorage !== 'undefined') {
                        localStorage.setItem('electronAdventureRankings', JSON.stringify(this.rankings));
                        console.log('排行榜已保存:', this.rankings);
                        return true;
                    }
                } catch (e) {
                    console.error('保存失败:', e);
                }
                return false;
            },

            // 添加新分数
            addScore(score) {
                // 确保分数是数字
                if (typeof score !== 'number' || isNaN(score)) {
                    console.error('无效分数:', score);
                    return false;
                }
                
                // 获取玩家名称
                let playerName = '游客';
                try {
                    const userInfoStr = localStorage.getItem('mainUserInfo');
                    if (userInfoStr) { // 先判断是否存在
                        const userInfo = JSON.parse(userInfoStr);
                        if (userInfo?.username) {
                            playerName = userInfo.username;
                        }
                    }
                } catch (e) {
                    console.log('使用默认用户名:', e);
                }
                const normalizedName = playerName.slice(0, 8) || '游客';
                
                // 查找玩家是否已有记录
                const existingIndex = this.rankings.findIndex(item => item.name === normalizedName);
                
                // 处理记录
                if (existingIndex !== -1) {
                    // 更新现有玩家的最高分
                    if (score > this.rankings[existingIndex].score) {
                        this.rankings[existingIndex] = {
                            name: normalizedName,
                            score: score,
                            date: this.formatDate(new Date())
                        };
                        console.log('更新记录:', normalizedName, score);
                    }
                } else {
                    // 添加新玩家记录
                    this.rankings.push({
                        name: normalizedName,
                        score: score,
                        date: this.formatDate(new Date())
                    });
                    console.log('添加新记录:', normalizedName, score);
                }
                
                // 排序并保留前10
                this.rankings.sort((a, b) => b.score - a.score);
                this.rankings = this.rankings.slice(0, 10);
                
                // 保存并返回结果
                const saved = this.save();
                this.render(); // 立即更新显示
                return saved;
            },

            // 格式化日期
            formatDate(date) {
                return `${date.getMonth() + 1}月${date.getDate()}日 ${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
            },

            // 渲染排行榜
            render() {
                const rankingListEl = document.getElementById('rankingList');
                if (!rankingListEl) return;
                
                rankingListEl.innerHTML = '';
                
                // 确保有数据可显示
                if (this.rankings.length === 0) {
                    const emptyItem = document.createElement('div');
                    emptyItem.className = 'text-center p-4 text-slate-400';
                    emptyItem.textContent = '暂无记录，快来创造第一个高分吧！';
                    rankingListEl.appendChild(emptyItem);
                    return;
                }
                
                this.rankings.forEach((item, index) => {
                    const rankItem = document.createElement('div');
                    rankItem.className = `flex justify-between items-center p-2 rounded-lg ${
                                index < 3 ? 'bg-yellow-900/30' : 'bg-slate-700/50'
                    }`;
            
                    let rankIcon = '';
                    if (index === 0) rankIcon = '<i class="fa fa-trophy text-yellow-500 mr-2"></i>';
                    if (index === 1) rankIcon = '<i class="fa fa-trophy text-gray-400 mr-2"></i>';
                    if (index === 2) rankIcon = '<i class="fa fa-trophy text-amber-700 mr-2"></i>';
            
                    rankItem.innerHTML = `
                        <div class="flex items-center">
                            <span class="w-6 text-center font-bold ${index < 3 ? 'text-yellow-400' : ''}">${index + 1}</span>
                            ${rankIcon}
                            <span class="ml-1">${item.name}</span>
                        </div>
                        <div class="flex items-center">
                            <span class="font-bold text-green-400 mr-4">${item.score}</span>
                            <span class="text-xs text-slate-400">${item.date}</span>
                        </div>
                    `;
                    rankingListEl.appendChild(rankItem);
                });
            }
        };
        
        // DOM元素
        const elements = {
            electron: document.getElementById('electron'),
            target: document.getElementById('target'),
            gameArea: document.getElementById('gameArea'),
            levelDisplay: document.getElementById('level'),
            scoreDisplay: document.getElementById('score'),
            timerDisplay: document.getElementById('timer'),
            restartBtn: document.getElementById('restartBtn'),
            leftFieldBtn: document.getElementById('leftFieldBtn'),
            rightFieldBtn: document.getElementById('rightFieldBtn'),
            upFieldBtn: document.getElementById('upFieldBtn'),
            downFieldBtn: document.getElementById('downFieldBtn'),
            messageModal: document.getElementById('messageModal'),
            modalTitle: document.getElementById('modalTitle'),
            modalMessage: document.getElementById('modalMessage'),
            modalBtn: document.getElementById('modalBtn'),
            statusAnnouncer: document.getElementById('statusAnnouncer')
        };
        
        // 屏幕阅读器通知
        function announceStatus(message) {
            elements.statusAnnouncer.textContent = '';
            // 使用setTimeout确保屏幕阅读器能捕捉到文本变化
            setTimeout(() => {
                elements.statusAnnouncer.textContent = message;
            }, 100);
        }
        
        // 初始化游戏
        function initGame() {
            // 增强错误处理
            enhanceErrorHandling();
            
            // 检查浏览器支持
            checkBrowserSupport();
            
            // 初始化成就系统
            achievements.load();
            
            // 初始化排行榜
            console.log('初始化排行榜...');
            rankingSystem.init();
            console.log('初始排行榜数据:', rankingSystem.rankings);
            
            // 设置游戏区域尺寸
            gameState.gameArea = elements.gameArea;
            updateGameDimensions();
            adjustGameParameters();
            
            // 初始化电子和目标位置
            gameState.electron.element = elements.electron;
            gameState.target.element = elements.target;
            gameState.target.size = elements.target.offsetWidth;
            
            // 存储电场按钮
            gameState.fieldButtons = [
                elements.leftFieldBtn,
                elements.rightFieldBtn,
                elements.upFieldBtn,
                elements.downFieldBtn
            ];
            
            // 增强按钮反馈
            enhanceButtonFeedback();
            
            // 添加事件监听器
            elements.leftFieldBtn.addEventListener('click', () => applyField('left'));
            elements.rightFieldBtn.addEventListener('click', () => applyField('right'));
            elements.upFieldBtn.addEventListener('click', () => applyField('up'));
            elements.downFieldBtn.addEventListener('click', () => applyField('down'));
            
            // 键盘控制
            document.addEventListener('keydown', (e) => {
                if (!gameState.isPlaying) return;
                
                switch(e.key) {
                    case 'ArrowLeft': applyField('left'); break;
                    case 'ArrowRight': applyField('right'); break;
                    case 'ArrowUp': applyField('up'); break;
                    case 'ArrowDown': applyField('down'); break;
                }
            });
            
            elements.restartBtn.addEventListener('click', restartGame);
            elements.modalBtn.addEventListener('click', () => {
                elements.messageModal.classList.add('hidden');
                if (!gameState.isPlaying) {
                    startLevel();
                }
            });
            
            // 窗口大小变化监听
            window.addEventListener('resize', () => {
                updateGameDimensions();
                adjustGameParameters();
                if (gameState.isPlaying) {
                    setRandomTargetPosition();
                }
                // 调整虚拟摇杆显示
                adjustVirtualJoystick();
            });
            
            // 排行榜按钮事件
            document.getElementById('rankingBtn').addEventListener('click', () => {
                console.log('打开排行榜，当前数据:', rankingSystem.rankings);
                rankingSystem.render();
                document.getElementById('rankingModal').classList.remove('hidden');
            });
            
            document.getElementById('closeRankingBtn').addEventListener('click', () => {
                document.getElementById('rankingModal').classList.add('hidden');
            });
            
            // 添加虚拟摇杆（移动设备）
            addVirtualJoystick();
            
            // 开始第一关
            showMessage('能量系统紧急告警', 
    '核心服务器遭遇粒子风暴，电子流失控导致系统崩溃。<br>你的任务是引导关键电子（e⁻）到达稳定区，逐步修复系统。', 
    '开始修复');
        }
        
        // 更新游戏区域尺寸
        function updateGameDimensions() {
            gameState.gameWidth = gameState.gameArea.offsetWidth;
            gameState.gameHeight = gameState.gameArea.offsetHeight;
        }
        
        // 根据屏幕尺寸调整游戏参数
        function adjustGameParameters() {
            if (window.innerWidth < 640) {
                gameState.baseObstacleSize = 30;
                gameState.minObstacleDistance = Math.max(60, gameState.gameWidth * 0.15);
                gameState.electron.speed = 2.5;
            } else {
                gameState.baseObstacleSize = 36;
                gameState.minObstacleDistance = 80;
                gameState.electron.speed = 3;
            }
        }
        
        // 重置电子位置
        function resetElectronPosition() {
            gameState.electron.x = 30;
            gameState.electron.y = gameState.gameHeight / 2;
            gameState.electron.velocityX = 0;
            gameState.electron.velocityY = 0;
            updateElectronPosition();
        }
        
        // 设置随机目标位置
        function setRandomTargetPosition() {
            const padding = 40;
            const targetWidth = gameState.target.element.offsetWidth;
            const targetHeight = gameState.target.element.offsetHeight;
            
            const maxX = gameState.gameWidth - padding - targetWidth;
            const minX = gameState.gameWidth - padding * 2 - targetWidth;
            gameState.target.x = Math.random() * (maxX - minX) + minX;
            
            const maxY = gameState.gameHeight - padding - targetHeight;
            const minY = padding;
            gameState.target.y = Math.random() * (maxY - minY) + minY;
            
            gameState.target.x = Math.max(gameState.target.x, 0);
            gameState.target.y = Math.max(gameState.target.y, 0);
            
            gameState.target.element.style.left = `${gameState.target.x}px`;
            gameState.target.element.style.top = `${gameState.target.y}px`;
        }
        
        // 更新电子位置
        function updateElectronPosition() {
            // 根据屏幕尺寸调整摩擦系数
            if (window.innerWidth < 640) {
                gameState.electron.velocityX *= 0.95; // 小屏幕降低摩擦，操作更灵敏
                gameState.electron.velocityY *= 0.95;
            } else {
                gameState.electron.velocityX *= 0.97;
                gameState.electron.velocityY *= 0.97;
            }
            
            // 确保速度不会太小
            if (Math.abs(gameState.electron.velocityX) < 0.1) gameState.electron.velocityX = 0;
            if (Math.abs(gameState.electron.velocityY) < 0.1) gameState.electron.velocityY = 0;
            
            // 更新位置
            gameState.electron.x += gameState.electron.velocityX;
            gameState.electron.y += gameState.electron.velocityY;
            
            // 确保电子不会超出游戏区域
            if (gameState.electron.x < 0) gameState.electron.x = 0;
            if (gameState.electron.x > gameState.gameWidth - gameState.electron.size) {
                gameState.electron.x = gameState.gameWidth - gameState.electron.size;
            }
            if (gameState.electron.y < 0) gameState.electron.y = 0;
            if (gameState.electron.y > gameState.gameHeight - gameState.electron.size) {
                gameState.electron.y = gameState.gameHeight - gameState.electron.size;
            }
            
            // 应用位置
            gameState.electron.element.style.left = `${gameState.electron.x}px`;
            gameState.electron.element.style.top = `${gameState.electron.y}px`;
            
            // 检查是否到达目标
            checkTargetCollision();
            
            // 检查是否碰撞障碍物
            checkObstacleCollision();
        }
        
        // 应用电场力
        function applyField(direction) {
            if (!gameState.isPlaying) return;
            
            gameState.moves++;
            showFieldDirectionIndicator(direction);
            
            // 电子带负电，向电场相反方向移动
            switch(direction) {
                case 'left':    // 电场向左 → 电子受力向右
                    gameState.electron.velocityX += gameState.electron.speed;
                    createFieldEffect('left');
                    break;
                case 'right':   // 电场向右 → 电子受力向左
                    gameState.electron.velocityX -= gameState.electron.speed;
                    createFieldEffect('right');
                    break;
                case 'up':      // 电场向上 → 电子受力向下
                    gameState.electron.velocityY += gameState.electron.speed;
                    createFieldEffect('up');
                    break;
                case 'down':    // 电场向下 → 电子受力向上
                    gameState.electron.velocityY -= gameState.electron.speed;
                    createFieldEffect('down');
                    break;
            }
        }
        
        // 显示电场方向指示器
        function showFieldDirectionIndicator(direction) {
            // 先移除任何已存在的指示器
            const existingIndicator = document.querySelector('.direction-indicator');
            if (existingIndicator) {
                gameState.gameArea.removeChild(existingIndicator);
            }
            
            const indicator = document.createElement('div');
            indicator.className = 'direction-indicator absolute text-field text-4xl pointer-events-none z-10';
            
            // 设置指示器位置在电子附近
            indicator.style.left = `${gameState.electron.x + 40}px`;
            indicator.style.top = `${gameState.electron.y}px`;
            
            // 设置指示器图标
            switch(direction) {
                case 'left':
                    indicator.innerHTML = '<i class="fa fa-long-arrow-left"></i>';
                    break;
                case 'right':
                    indicator.innerHTML = '<i class="fa fa-long-arrow-right"></i>';
                    break;
                case 'up':
                    indicator.innerHTML = '<i class="fa fa-long-arrow-up"></i>';
                    break;
                case 'down':
                    indicator.innerHTML = '<i class="fa fa-long-arrow-down"></i>';
                    break;
            }
            
            gameState.gameArea.appendChild(indicator);
            
            // 1秒后移除指示器
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.style.opacity = '0';
                    setTimeout(() => {
                        if (indicator.parentNode) {
                            gameState.gameArea.removeChild(indicator);
                        }
                    }, 500);
                }
            }, 1000);
        }
        
        // 创建电场视觉效果（使用对象池优化）
        function createFieldEffect(direction) {
            // 复用现有元素而非每次创建新元素
            let fieldEffect = document.querySelector('.field-effect.hidden');
            if (!fieldEffect) {
                fieldEffect = document.createElement('div');
                fieldEffect.className = 'field-effect absolute bg-field/20 field-glow transition-opacity duration-500';
                gameState.gameArea.appendChild(fieldEffect);
            } else {
                fieldEffect.classList.remove('hidden');
                fieldEffect.style.opacity = '1';
            }
            
            // 根据方向设置电场效果的位置和大小
            if (direction === 'left') {
                fieldEffect.style.height = '100%';
                fieldEffect.style.width = '30%';
                fieldEffect.style.top = '0';
                fieldEffect.style.left = '0';
            } else if (direction === 'right') {
                fieldEffect.style.height = '100%';
                fieldEffect.style.width = '30%';
                fieldEffect.style.top = '0';
                fieldEffect.style.right = '0';
            } else if (direction === 'up') {
                fieldEffect.style.width = '100%';
                fieldEffect.style.height = '30%';
                fieldEffect.style.left = '0';
                fieldEffect.style.top = '0';
            } else if (direction === 'down') {
                fieldEffect.style.width = '100%';
                fieldEffect.style.height = '30%';
                fieldEffect.style.left = '0';
                fieldEffect.style.bottom = '0';
            }
            
            // 电场效果显示时间
            setTimeout(() => {
                fieldEffect.style.opacity = '0';
                setTimeout(() => {
                    fieldEffect.classList.add('hidden');
                }, 500);
            }, 500);
        }
        
        // 检查是否到达目标
        function checkTargetCollision() {
            // 简化的碰撞检测
            const dx = Math.abs(gameState.electron.x + gameState.electron.size/2 - (gameState.target.x + gameState.target.size/2));
            const dy = Math.abs(gameState.electron.y + gameState.electron.size/2 - (gameState.target.y + gameState.target.size/2));
            
            if (dx < (gameState.electron.size + gameState.target.size)/2 && 
                dy < (gameState.electron.size + gameState.target.size)/2) {
                completeLevel();
            }
        }
        
        // 检查是否碰撞障碍物
        function checkObstacleCollision() {
            const electronCenterX = gameState.electron.x + gameState.electron.size/2;
            const electronCenterY = gameState.electron.y + gameState.electron.size/2;
            
            // 使用空间分区优化碰撞检测
            checkProtonCollisionWithSpatialPartition(electronCenterX, electronCenterY);
            checkTrapCollisionWithSpatialPartition(electronCenterX, electronCenterY);
        }
        
        // 使用空间分区优化质子碰撞检测
        function checkProtonCollisionWithSpatialPartition(electronCenterX, electronCenterY) {
            const gridSize = 100;
            const grid = {};
            
            // 初始化网格
            gameState.protons.forEach(proton => {
                const gridX = Math.floor(proton.x / gridSize);
                const gridY = Math.floor(proton.y / gridSize);
                const key = `${gridX},${gridY}`;
                if (!grid[key]) grid[key] = [];
                grid[key].push(proton);
            });
            
            // 检测时只检查电子所在网格及相邻网格
            const electronGridX = Math.floor(electronCenterX / gridSize);
            const electronGridY = Math.floor(electronCenterY / gridSize);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const key = `${electronGridX + dx},${electronGridY + dy}`;
                    if (grid[key]) {
                        // 只检查这些质子
                        grid[key].forEach(proton => {
                            const dx = Math.abs(electronCenterX - (proton.x + proton.size/2));
                            const dy = Math.abs(electronCenterY - (proton.y + proton.size/2));
                            
                            if (dx < (gameState.electron.size + proton.size)/2 && dy < (gameState.electron.size + proton.size)/2) {
                                gameOver('碰撞质子！', '电子与质子相互吸引发生碰撞');
                                return;
                            }
                        });
                    }
                }
            }
        }
        
        // 使用空间分区优化陷阱碰撞检测
        function checkTrapCollisionWithSpatialPartition(electronCenterX, electronCenterY) {
            const gridSize = 100;
            const grid = {};
            
            // 初始化网格
            gameState.traps.forEach(trap => {
                const gridX = Math.floor(trap.x / gridSize);
                const gridY = Math.floor(trap.y / gridSize);
                const key = `${gridX},${gridY}`;
                if (!grid[key]) grid[key] = [];
                grid[key].push(trap);
            });
            
            // 检测时只检查电子所在网格及相邻网格
            const electronGridX = Math.floor(electronCenterX / gridSize);
            const electronGridY = Math.floor(electronCenterY / gridSize);
            
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const key = `${electronGridX + dx},${electronGridY + dy}`;
                    if (grid[key]) {
                        // 只检查这些陷阱
                        grid[key].forEach(trap => {
                            const dx = Math.abs(electronCenterX - (trap.x + trap.size/2));
                            const dy = Math.abs(electronCenterY - (trap.y + trap.size/2));
                            
                            if (dx < (gameState.electron.size + trap.size)/2 && dy < (gameState.electron.size + trap.size)/2) {
                                gameOver('触发电场陷阱！', '电子进入了不稳定的电场区域');
                                return;
                            }
                        });
                    }
                }
            }
        }
        
        // 检查新位置是否与现有障碍物太近
        function isPositionTooClose(x, y, size, obstacles) {
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const dx = Math.abs(x - obstacle.x);
                const dy = Math.abs(y - obstacle.y);
                const minAllowedDistance = (size + obstacle.size) / 2 + gameState.minObstacleDistance;
                
                if (dx < minAllowedDistance && dy < minAllowedDistance) {
                    return true; // 太近了
                }
            }
            return false;
        }
        
        // 创建质子障碍物
        function createProtons(count) {
            // 先清除现有质子
            gameState.protons.forEach(proton => {
                if (proton.element.parentNode) {
                    gameState.gameArea.removeChild(proton.element);
                }
            });
            gameState.protons = [];
            
            const padding = 60;
            const protonSize = gameState.baseObstacleSize;
            const maxAttempts = 50; // 最大尝试次数，避免无限循环
            
            // 合并所有已存在的障碍物用于碰撞检测
            const allObstacles = [...gameState.traps];
            
            for (let i = 0; i < count; i++) {
                let x, y;
                let attempts = 0;
                
                // 尝试生成不与其他障碍物重叠的位置
                do {
                    x = Math.random() * (gameState.gameWidth - protonSize - padding * 2) + padding;
                    y = Math.random() * (gameState.gameHeight - protonSize - padding * 2) + padding;
                    attempts++;
                    
                    // 如果尝试次数过多还没找到合适位置，减少间距要求
                    if (attempts > maxAttempts / 2) {
                        gameState.minObstacleDistance = Math.max(30, gameState.minObstacleDistance - 5);
                    }
                } while (
                    // 远离电子
                    (Math.abs(x - gameState.electron.x) < 100 && Math.abs(y - gameState.electron.y) < 100) ||
                    // 远离目标
                    (Math.abs(x - gameState.target.x) < 100 && Math.abs(y - gameState.target.y) < 100) ||
                    // 远离其他障碍物
                    isPositionTooClose(x, y, protonSize, allObstacles) ||
                    // 尝试次数过多时强制退出
                    attempts >= maxAttempts
                );
                
                const proton = document.createElement('div');
                proton.className = 'absolute bg-secondary rounded-full proton-glow spin-slow';
                proton.style.width = `${protonSize}px`;
                proton.style.height = `${protonSize}px`;
                proton.style.left = `${x}px`;
                proton.style.top = `${y}px`;
                proton.innerHTML = `
                    <div class="absolute -inset-1 bg-gradient-to-r from-secondary to-orange-300 rounded-full opacity-30"></div>
                    <div class="absolute inset-0 flex items-center justify-center text-white text-xs font-bold">p⁺</div>
                `;
                
                gameState.gameArea.appendChild(proton);
                const newProton = { element: proton, x, y, size: protonSize };
                gameState.protons.push(newProton);
                allObstacles.push(newProton); // 添加到障碍物列表用于后续检测
            }
        }
        
        // 创建陷阱
        function createTraps(count) {
            // 先清除现有陷阱
            gameState.traps.forEach(trap => {
                if (trap.element.parentNode) {
                    gameState.gameArea.removeChild(trap.element);
                }
            });
            gameState.traps = [];
            
            const padding = 60;
            const trapSize = gameState.baseObstacleSize + 12; // 陷阱比质子稍大
            const maxAttempts = 50; // 最大尝试次数
            
            // 合并所有已存在的障碍物用于碰撞检测
            const allObstacles = [...gameState.protons];
            
            for (let i = 0; i < count; i++) {
                let x, y;
                let attempts = 0;
                
                // 尝试生成不与其他障碍物重叠的位置
                do {
                    x = Math.random() * (gameState.gameWidth - trapSize - padding * 2) + padding;
                    y = Math.random() * (gameState.gameHeight - trapSize - padding * 2) + padding;
                    attempts++;
                    
                    // 如果尝试次数过多还没找到合适位置，减少间距要求
                    if (attempts > maxAttempts / 2) {
                        gameState.minObstacleDistance = Math.max(30, gameState.minObstacleDistance - 5);
                    }
                } while (
                    // 远离电子
                    (Math.abs(x - gameState.electron.x) < 120 && Math.abs(y - gameState.electron.y) < 120) ||
                    // 远离目标
                    (Math.abs(x - gameState.target.x) < 120 && Math.abs(y - gameState.target.y) < 120) ||
                    // 远离其他障碍物
                    isPositionTooClose(x, y, trapSize, allObstacles) ||
                    // 尝试次数过多时强制退出
                    attempts >= maxAttempts
                );
                
                const trap = document.createElement('div');
                trap.className = 'absolute bg-danger rounded-full trap-pulse';
                trap.style.width = `${trapSize}px`;
                trap.style.height = `${trapSize}px`;
                trap.style.left = `${x}px`;
                trap.style.top = `${y}px`;
                trap.innerHTML = `
                    <div class="absolute inset-0 flex items-center justify-center text-white text-xs font-bold">危险</div>
                `;
                
                gameState.gameArea.appendChild(trap);
                const newTrap = { element: trap, x, y, size: trapSize };
                gameState.traps.push(newTrap);
                allObstacles.push(newTrap); // 添加到障碍物列表用于后续检测
            }
        }
        
        // 根据屏幕尺寸和玩家表现调整障碍物数量
        function getObstacleCount() {
            // 计算玩家表现因子
            const performanceFactor = gameState.score / Math.max(gameState.moves, 1);
            
            // 基础障碍物数量
            let baseObstacles = Math.min(5, Math.floor(gameState.level / 2));
            
            // 根据表现调整
            if (performanceFactor > 100) {
                baseObstacles += 1; // 表现好，增加难度
            } else if (performanceFactor < 30) {
                baseObstacles = Math.max(1, baseObstacles - 1); // 表现差，降低难度
            }
            
            // 小屏幕减少障碍物数量
            if (window.innerWidth < 640) {
                return {
                    protonCount: Math.min(1 + Math.floor(baseObstacles / 2), 3),
                    trapCount: Math.min(0 + Math.floor((baseObstacles - 3) / 5), 1)
                };
            } else {
                // 大屏幕正常数量
                return {
                    protonCount: Math.min(2 + Math.floor(baseObstacles / 2), 6),
                    trapCount: Math.min(1 + Math.floor((baseObstacles - 1) / 3), 4)
                };
            }
        }
        
        // 开始关卡
        function startLevel() {
            // 重置游戏状态
            gameState.moves = 0;
            gameState.levelStartTime = Date.now(); // 记录关卡开始时间
            gameState.timeLeft = 30 + (gameState.level - 1) * 5;
            resetElectronPosition();
            setRandomTargetPosition();
            
            // 更新显示
            elements.levelDisplay.textContent = gameState.level;
            elements.timerDisplay.textContent = gameState.timeLeft;
            
            announceStatus(`开始第${gameState.level}关，剩余时间${gameState.timeLeft}秒`);
            
            // 根据屏幕尺寸获取障碍物数量并创建
            const { protonCount, trapCount } = getObstacleCount();
            if (window.innerWidth < 640) {
                // 小屏幕用空闲回调优化性能
                requestIdleCallback(() => {
                    createProtons(protonCount);
                    createTraps(trapCount);
                }, { timeout: 1000 });
            } else {
                createProtons(protonCount);
                createTraps(trapCount);
            }
            
            // 启动计时器
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            gameState.timerInterval = setInterval(() => {
                gameState.timeLeft--;
                elements.timerDisplay.textContent = gameState.timeLeft;
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timerInterval);
                    gameOver('时间到！', '未能在规定时间内到达目标');
                }
            }, 1000);
            
            // 启动游戏循环
            startGameLoop();
            
            gameState.isPlaying = true;
        }
        
        // 使用requestAnimationFrame优化游戏循环
        function startGameLoop() {
            if (gameState.gameLoop) cancelAnimationFrame(gameState.gameLoop);
            
            let lastFrameTime = 0;
            const maxFps = 30; // 限制帧率平衡性能
            const frameInterval = 1000 / maxFps;
            
            const gameLoop = (timestamp) => {
                if (!timestamp) timestamp = performance.now();
                if (timestamp - lastFrameTime < frameInterval) {
                    gameState.gameLoop = requestAnimationFrame(gameLoop);
                    return;
                }
                lastFrameTime = timestamp;
                
                updateElectronPosition();
                gameState.gameLoop = requestAnimationFrame(gameLoop);
            };
            
            gameState.gameLoop = requestAnimationFrame(gameLoop);
        }
        
        // 完成关卡
        function completeLevel() {
            if (!gameState.isPlaying) return;
            
            // 停止游戏循环和计时器
            clearInterval(gameState.timerInterval);
            cancelAnimationFrame(gameState.gameLoop);
            gameState.timerInterval = null;
            gameState.gameLoop = null;
            
            gameState.isPlaying = false;
            
            // 计算关卡用时
            gameState.currentLevelTime = Math.round((Date.now() - gameState.levelStartTime) / 1000);
            gameState.consecutiveLevels++; // 增加连续关卡计数
            
            // 计算得分
            const timeBonus = gameState.timeLeft * 10;
            const movePenalty = Math.min(gameState.moves * 5, 100);
            const levelScore = 100 + timeBonus - movePenalty;
            gameState.score += levelScore;
            
            // 更新显示
            elements.scoreDisplay.textContent = gameState.score;
            
            // 检查成就
            achievements.checkConditions({
                level: gameState.level,
                success: true,
                moves: gameState.moves,
                timeTaken: gameState.currentLevelTime,
                consecutiveLevels: gameState.consecutiveLevels
            });
            
            // 关卡过渡动画
            elements.gameArea.style.opacity = '0.5';
            
            // 准备下一关
            gameState.level++;
            
            // 添加到排行榜
            console.log('关卡完成，添加分数:', gameState.score);
            rankingSystem.addScore(gameState.score);
            
            // 关卡提示信息
            let levelMessage = '';
            if (gameState.level === 2) {
                levelMessage = '第一阶段修复完成！系统能量恢复15%，但区域出现更多质子干扰。';
            } else if (gameState.level === 3) {
                levelMessage = '第二阶段修复成功！注意：区域开始出现更多能量陷阱。';
            } else if (gameState.level === 7) {
                levelMessage = '干得漂亮！修复了六个阶段！粒子风暴增强。';
            } else {
                levelMessage = `第${gameState.level - 1}阶段修复完成，系统能量提升！`;
            }
            
            announceStatus(`第${gameState.level - 1}关完成，获得${levelScore}分，总分${gameState.score}分`);
            
            // 恢复游戏区域透明度并显示消息
            setTimeout(() => {
                elements.gameArea.style.opacity = '1';
                showMessage(
                    `修复阶段 ${gameState.level - 1} 完成！`,
                    `${levelMessage}<br>获得 ${levelScore} 点能量！剩余时间奖励: ${timeBonus} 点，操作消耗: ${movePenalty} 点`,
                    `进入阶段 ${gameState.level}`
                );
            }, 500);
        }
        
        // 游戏结束
        function gameOver(title, message) {
            gameState.isPlaying = false;
            
            // 停止游戏循环和计时器
            clearInterval(gameState.timerInterval);
            cancelAnimationFrame(gameState.gameLoop);
            gameState.timerInterval = null;
            gameState.gameLoop = null;
            
            // 重置连续关卡计数
            gameState.consecutiveLevels = 0;
            
            // 失败原因说明
            let failReason = '';
            if (title === '碰撞质子！') {
                failReason = '电子被质子的强吸引力捕获，导致局部电路烧毁。';
            } else if (title === '触发电场陷阱！') {
                failReason = '能量陷阱释放的脉冲摧毁了电子的稳定结构。';
            } else if (title === '时间到！') {
                failReason = '电子未能及时到达稳定区，能量耗尽消失。';
            }
            
            // 添加分数到排行榜
            console.log('游戏结束，添加分数:', gameState.score);
            const added = rankingSystem.addScore(gameState.score);
            console.log('分数添加结果:', added ? '成功' : '失败');
            
            announceStatus(`${title}，最终得分${gameState.score}分`);
            
            showMessage(
                `系统修复失败`,
                `${failReason}<br>当前系统能量: ${gameState.score}，请重新尝试修复。`,
                '重启修复'
            );
        }
        
        // 重新开始游戏
        function restartGame() {
            gameState.isPlaying = false;
            
            // 停止所有计时器和动画
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            if (gameState.gameLoop) {
                cancelAnimationFrame(gameState.gameLoop);
            }
            
            // 重置游戏状态
            gameState.level = 1;
            gameState.score = 0;
            gameState.consecutiveLevels = 0;
            gameState.minObstacleDistance = window.innerWidth < 640 ? 60 : 80;
            
            // 更新显示
            elements.levelDisplay.textContent = gameState.level;
            elements.scoreDisplay.textContent = gameState.score;
            
            // 隐藏弹窗并开始第一关
            elements.messageModal.classList.add('hidden');
            startLevel();
        }
        
        // 显示消息弹窗
        function showMessage(title, message, buttonText) {
            elements.modalTitle.textContent = title;
            elements.modalMessage.innerHTML = message;
            elements.modalBtn.textContent = buttonText;
            elements.messageModal.classList.remove('hidden');
        }
        
        // 增强按钮反馈
        function enhanceButtonFeedback() {
            gameState.fieldButtons.forEach(btn => {
                // 按钮按下视觉反馈
                btn.addEventListener('mousedown', () => {
                    btn.classList.add('scale-95', 'bg-slate-600');
                });
                
                btn.addEventListener('mouseup', () => {
                    btn.classList.remove('scale-95', 'bg-slate-600');
                });
                
                btn.addEventListener('mouseleave', () => {
                    btn.classList.remove('scale-95', 'bg-slate-600');
                });
                
                // 触摸设备支持
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    btn.classList.add('scale-95', 'bg-slate-600');
                });
                
                btn.addEventListener('touchend', () => {
                    btn.classList.remove('scale-95', 'bg-slate-600');
                });
                
                // 添加触觉反馈（如果支持）
                btn.addEventListener('click', () => {
                    if ('vibrate' in navigator) {
                        navigator.vibrate(50);
                    }
                });
            });
        }
        
        // 为移动设备添加虚拟摇杆
        function addVirtualJoystick() {
            const joystickContainer = document.getElementById('virtualJoystick');
            const joystickHandle = document.getElementById('joystickHandle');
            
            // 根据屏幕尺寸决定是否显示
            adjustVirtualJoystick();
            
            let isDragging = false;
            const centerX = 12; // 容器宽度的一半 (24/2)
            const centerY = 12; // 容器高度的一半 (24/2)
            const maxDistance = 40;
            
            // 触摸事件处理
            joystickContainer.addEventListener('touchstart', (e) => {
                isDragging = true;
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isDragging || !gameState.isPlaying) return;
                
                const rect = joystickContainer.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;
                
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 限制在最大距离内
                const limitedDistance = Math.min(distance, maxDistance);
                const angle = Math.atan2(dy, dx);
                
                // 更新摇杆位置
                joystickHandle.style.left = `${centerX + Math.cos(angle) * limitedDistance}px`;
                joystickHandle.style.top = `${centerY + Math.sin(angle) * limitedDistance}px`;
                
                // 确定方向并应用电场
                if (Math.abs(dx) > Math.abs(dy)) {
                    applyField(dx > 0 ? 'right' : 'left');
                } else {
                    applyField(dy > 0 ? 'down' : 'up');
                }
            });
            
            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    // 重置摇杆位置
                    joystickHandle.style.left = '50%';
                    joystickHandle.style.top = '50%';
                }
            });
        }
        
        // 根据屏幕尺寸调整虚拟摇杆显示
        function adjustVirtualJoystick() {
            const joystick = document.getElementById('virtualJoystick');
            if (window.innerWidth < 640) {
                joystick.classList.remove('hidden');
            } else {
                joystick.classList.add('hidden');
            }
        }
        
        // 增强错误处理
        function enhanceErrorHandling() {
            // 捕获全局错误
            window.addEventListener('error', (e) => {
                console.error('游戏错误:', e);
                showMessage('游戏错误', '游戏发生错误，将尝试恢复', '重新开始', () => {
                    restartGame();
                });
            });
        }
        
        // 检查浏览器特性支持
        function checkBrowserSupport() {
            const unsupportedFeatures = [];
            
            if (!window.requestAnimationFrame) {
                unsupportedFeatures.push('高级动画支持');
            }
            
            try {
                if (typeof localStorage === 'undefined') {
                    unsupportedFeatures.push('本地存储');
                } else {
                    // 测试localStorage是否可用
                    const testKey = 'test_' + Date.now();
                    localStorage.setItem(testKey, 'test');
                    localStorage.removeItem(testKey);
                }
            } catch (e) {
                unsupportedFeatures.push('本地存储');
            }
            
            if (unsupportedFeatures.length > 0) {
                showMessage(
                    '浏览器兼容性警告',
                    `您的浏览器可能不支持以下功能: ${unsupportedFeatures.join(', ')}，游戏体验可能受影响`,
                    '继续'
                );
            }
        }
        
        // 初始化游戏
        window.addEventListener('load', initGame);
    </script>
    <div class="back-container">
        <button class="back-to-home bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg transition-colors" onclick="window.location.href='indexdaohang.html'">返回导航页面</button>
    </div>

</body>
</html>
