<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>è´¨å­VSç”µå­ | é‡å­è¿·å®«å¯¹å†³</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* ====== åŸºç¡€é‡ç½® ====== */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* ç¦æ­¢é¡µé¢æ»šåŠ¨ï¼Œå…è®¸æ¨ªå± */
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            background: #0f172a;
        }
        
        /* æ¨ªå±å¼ºåˆ¶ */
        @media (orientation: portrait) {
            #app {
                transform: rotate(90deg);
                transform-origin: center center;
                width: 100vh;
                height: 100vw;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) rotate(90deg);
            }
            
            body::before {
                content: "è¯·å°†è®¾å¤‡æ—‹è½¬è‡³æ¨ªå±ä»¥è·å¾—æœ€ä½³æ¸¸æˆä½“éªŒ";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.5rem;
                z-index: 9999;
                padding: 2rem;
                text-align: center;
            }
        }
        
        /* ====== é¢œè‰²å˜é‡ ====== */
        :root {
            --primary-blue: #3b82f6;
            --primary-red: #ef4444;
            --neon-cyan: #00f7ff;
            --dark-bg: #0f172a;
            --card-bg: #1e293b;
            --text-light: #e2e8f0;
            --text-dim: #94a3b8;
        }
        
        /* ====== ä¸»å®¹å™¨ ====== */
        #app {
            width: 100vw;
            height: 100vh;
            background: var(--dark-bg);
            color: var(--text-light);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        
        /* ====== åœºæ™¯åŸºç¡€æ ·å¼ ====== */
        .scene {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            overflow: hidden;
        }
        
        .active {
            display: block;
        }
        
        /* ====== 1. ä¸»èœå•åœºæ™¯ ====== */
        #menuScene {
            background: linear-gradient(135deg, 
                rgba(15, 23, 42, 0.95) 0%, 
                rgba(30, 41, 59, 0.9) 100%),
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%233b82f6' fill-opacity='0.05' fill-rule='evenodd'/%3E%3C/svg%3E");
        }
        
        .menu-header {
            text-align: center;
            padding: 2rem 1rem 1rem;
        }
        
        .logo {
            font-size: 3.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, var(--primary-blue), var(--primary-red));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-block;
        }
        
        .game-title {
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: white;
            animation: textGlow 3s ease-in-out infinite alternate;
        }
        
        .game-subtitle {
            font-size: 1.1rem;
            color: var(--text-dim);
            max-width: 500px;
            margin: 0 auto 2rem;
            line-height: 1.6;
        }
        
        /* ====== æŒ‰é’®æ ·å¼ ====== */
        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin: 0.5rem;
            min-width: 200px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-blue), #2563eb);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--primary-red), #dc2626);
            color: white;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }
        
        .btn-secondary {
            background: transparent;
            color: var(--primary-blue);
            border: 2px solid var(--primary-blue);
        }
        
        .btn-secondary:hover {
            background: rgba(59, 130, 246, 0.1);
        }
        
        /* ====== èœå•å†…å®¹ ====== */
        .menu-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: calc(100% - 200px);
            padding: 1rem;
        }
        
        .btn-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin: 2rem 0;
        }
        
        .game-stats {
            display: flex;
            gap: 2rem;
            margin-top: 2rem;
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            display: block;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            margin-top: 0.25rem;
        }
        
        /* ====== é¡µè„š ====== */
        .footer {
            position: absolute;
            bottom: 1rem;
            width: 100%;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.85rem;
            padding: 0 1rem;
        }
        
        /* ====== åŠ¨ç”»å®šä¹‰ ====== */
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        
        @keyframes searchingDot {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 5px currentColor); }
            50% { filter: drop-shadow(0 0 20px currentColor); }
        }
        
        @keyframes textGlow {
            from {
                text-shadow: 0 0 10px rgba(59, 130, 246, 0.5),
                             0 0 20px rgba(59, 130, 246, 0.3);
            }
            to {
                text-shadow: 0 0 20px rgba(59, 130, 246, 0.8),
                             0 0 40px rgba(59, 130, 246, 0.5),
                             0 0 60px rgba(59, 130, 246, 0.3);
            }
        }
        
        /* ====== ç§»åŠ¨æŒ‰é’®æ ·å¼ ====== */
        .mobile-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
            user-select: none;
            touch-action: manipulation;
        }
        
        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(0.95);
        }
        
        .attack-btn {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.5);
        }
        
        .attack-btn:active {
            background: rgba(239, 68, 68, 0.3);
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- åœºæ™¯1: ä¸»èœå• -->
        <div id="menuScene" class="scene active">
            <div class="menu-header">
                <div class="logo">âš›ï¸</div>
                <h1 class="game-title">è´¨å­VSç”µå­</h1>
                <p class="game-subtitle">
                    åœ¨é‡å­è¿·å®«ä¸­å±•å¼€å¾®è§‚å¯¹å†³ï¼å‘å°„ç²’å­ï¼Œèº²é¿å¢™å£ï¼Œå‡»è´¥å¯¹æ‰‹ã€‚
                    å®æ—¶åŒ¹é…ï¼Œå…¬å¹³ç«æŠ€ï¼Œä½“éªŒç‰©ç†æˆ˜æ–—çš„ä¹è¶£ã€‚
                </p>
            </div>
            
            <div class="menu-content">
                <div class="btn-group">
                    <button id="matchBtn" class="btn btn-primary" onclick="startMatchmaking()">
                        <span>ğŸ®</span> å¼€å§‹åŒ¹é…
                    </button>
                    <button id="howToPlayBtn" class="btn btn-secondary" onclick="showHowToPlay()">
                        <span>â“</span> æ¸¸æˆè¯´æ˜
                    </button>
                    <button id="testBtn" class="btn btn-secondary" onclick="testMultiplayerConnection()" style="margin-top: 1rem;">
                        <span>ğŸ§ª</span> æµ‹è¯•è¿æ¥
                    </button>
                </div>
                
                <div class="game-stats">
                    <div class="stat-item">
                        <span>åœ¨çº¿ç©å®¶</span>
                        <span class="stat-value" id="onlineCount">128</span>
                    </div>
                    <div class="stat-item">
                        <span>ä»Šæ—¥å¯¹æˆ˜</span>
                        <span class="stat-value" id="dailyMatches">892</span>
                    </div>
                    <div class="stat-item">
                        <span>åŒ¹é…é€Ÿåº¦</span>
                        <span class="stat-value" id="matchSpeed">3.2s</span>
                    </div>
                </div>
            </div>
            
            <div class="footer">
                <p>é‡å­è¿·å®«å¯¹å†³ v1.0 | ä¸“ä¸ºå®æ—¶å¯¹æˆ˜è®¾è®¡ | æ¨èæ¨ªå±æ¸¸æˆ</p>
            </div>
        </div>

        <!-- åœºæ™¯2: åŒ¹é…ä¸­ -->
        <div id="matchingScene" class="scene">
            <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center;">
                <div style="margin-bottom: 2rem;">
                    <div style="font-size: 4rem; margin-bottom: 1rem; animation: pulse 1.5s infinite;">ğŸ”</div>
                    <h2 style="font-size: 2rem; margin-bottom: 0.5rem; color: white;">å¯»æ‰¾å¯¹æ‰‹ä¸­</h2>
                    <p style="color: var(--text-dim); max-width: 400px; margin: 0 auto 2rem;">
                        æ­£åœ¨ä¸ºä½ å¯»æ‰¾å®åŠ›ç›¸å½“çš„å¯¹æ‰‹...é‡å­ç½‘ç»œæ­£åœ¨æ‰«æå¯ç”¨ç©å®¶ã€‚
                    </p>
                </div>
                
                <div style="background: rgba(30, 41, 59, 0.8); border-radius: 16px; padding: 2rem; border: 1px solid rgba(59, 130, 246, 0.3); max-width: 500px; width: 100%; margin-bottom: 2rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 1rem; color: var(--text-dim);">
                        <span>åŒ¹é…æ—¶é—´</span>
                        <span id="matchTimer" style="color: white; font-weight: bold;">0</span>
                    </div>
                    
                    <div style="height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden; margin-bottom: 1.5rem;">
                        <div id="matchProgress" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--primary-blue), #60a5fa); border-radius: 4px; transition: width 0.3s;"></div>
                    </div>
                    
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-bottom: 1.5rem;">
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: rgba(59, 130, 246, 0.3); animation: searchingDot 1s infinite;"></div>
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: rgba(59, 130, 246, 0.5); animation: searchingDot 1s infinite 0.2s;"></div>
                        <div style="width: 12px; height: 12px; border-radius: 50%; background: rgba(59, 130, 246, 0.7); animation: searchingDot 1s infinite 0.4s;"></div>
                    </div>
                    
                    <p id="matchStatus" style="color: var(--text-dim); font-size: 0.9rem;">
                        æ‰«æç©å®¶... æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ... ä¼˜åŒ–åŒ¹é…...
                    </p>
                </div>
                
                <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                    <button onclick="cancelMatchmaking()" class="btn btn-danger">
                        <span>âŒ</span> å–æ¶ˆåŒ¹é…
                    </button>
                </div>
            </div>
        </div>

        <!-- åœºæ™¯3: æ¸¸æˆå¤§å… -->
        <div id="lobbyScene" class="scene">
            <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center;">
                <div style="margin-bottom: 2rem;">
                    <h2 style="font-size: 2rem; margin-bottom: 0.5rem; color: white;">æ¸¸æˆå¤§å…</h2>
                    <p style="color: var(--text-dim); max-width: 500px; margin: 0 auto;">
                        å·²æ‰¾åˆ°å¯¹æ‰‹ï¼åŒæ–¹ç¡®è®¤å‡†å¤‡åï¼Œæ¸¸æˆå°†åœ¨5ç§’åå¼€å§‹ã€‚
                    </p>
                </div>
                
                <div style="display: flex; flex-wrap: wrap; gap: 2rem; justify-content: center; margin-bottom: 3rem; width: 100%; max-width: 800px;">
                    <!-- ç©å®¶1å¡ç‰‡ï¼ˆä½ ï¼‰ -->
                    <div id="player1Card" style="flex: 1; min-width: 250px; background: rgba(30, 41, 59, 0.9); border-radius: 16px; padding: 2rem; border: 2px solid var(--primary-blue); backdrop-filter: blur(10px);">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">âš›ï¸</div>
                        <h3 style="font-size: 1.5rem; margin-bottom: 0.5rem; color: white;" id="player1Role">ç­‰å¾…åˆ†é…</h3>
                        <p style="color: var(--text-dim); margin-bottom: 1rem;">ç©å®¶ (ä½ )</p>
                        
                        <div style="margin: 1.5rem 0; padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 8px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <div id="player1StatusDot" style="width: 12px; height: 12px; border-radius: 50%; background: #64748b;"></div>
                                <span id="player1StatusText">æœªå‡†å¤‡</span>
                            </div>
                            <button id="player1ReadyBtn" onclick="togglePlayerReady()" 
                                    style="padding: 0.75rem 2rem; background: var(--primary-blue); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; width: 100%; transition: all 0.2s;">
                                ç‚¹å‡»å‡†å¤‡
                            </button>
                        </div>
                    </div>
                    
                    <!-- VS æ ‡å¿— -->
                    <div style="display: flex; align-items: center; justify-content: center; min-width: 100px;">
                        <div style="font-size: 2.5rem; color: var(--text-dim); background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 50%;">âš¡</div>
                    </div>
                    
                    <!-- ç©å®¶2å¡ç‰‡ï¼ˆå¯¹æ‰‹ï¼‰ -->
                    <div id="player2Card" style="flex: 1; min-width: 250px; background: rgba(30, 41, 59, 0.9); border-radius: 16px; padding: 2rem; border: 2px solid var(--primary-red); backdrop-filter: blur(10px);">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">âš¡</div>
                        <h3 style="font-size: 1.5rem; margin-bottom: 0.5rem; color: white;" id="player2Role">ç­‰å¾…å¯¹æ‰‹</h3>
                        <p style="color: var(--text-dim); margin-bottom: 1rem;">å¯¹æ‰‹</p>
                        
                        <div style="margin: 1.5rem 0; padding: 1rem; background: rgba(239, 68, 68, 0.1); border-radius: 8px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; margin-bottom: 1rem;">
                                <div id="player2StatusDot" style="width: 12px; height: 12px; border-radius: 50%; background: #64748b;"></div>
                                <span id="player2StatusText">ç­‰å¾…ä¸­</span>
                            </div>
                            <div style="padding: 0.75rem; background: rgba(239, 68, 68, 0.2); border-radius: 8px; color: var(--text-dim);">
                                <span id="opponentAction">ç­‰å¾…å¯¹æ‰‹å‡†å¤‡...</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- å€’è®¡æ—¶æ˜¾ç¤º -->
                <div id="lobbyCountdown" style="display: none; background: linear-gradient(135deg, var(--primary-blue), var(--primary-red)); padding: 2rem 3rem; border-radius: 16px; margin-bottom: 2rem; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);">
                    <div style="font-size: 1.2rem; margin-bottom: 1rem; color: white;">æ¸¸æˆå³å°†å¼€å§‹</div>
                    <div id="countdownNumber" style="font-size: 4rem; font-weight: bold; color: white; animation: pulse 1s infinite;">5</div>
                </div>
            </div>
        </div>

        <!-- åœºæ™¯4: åŠ è½½ä¸­ -->
        <div id="loadingScene" class="scene">
            <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center; background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.95) 100%);">
                <div style="margin-bottom: 3rem;">
                    <div style="font-size: 4rem; margin-bottom: 1rem; animation: spin 2s linear infinite;">âš™ï¸</div>
                    <h2 style="font-size: 2rem; margin-bottom: 0.5rem; color: white;">é‡å­æˆ˜åœºç”Ÿæˆä¸­</h2>
                    <p style="color: var(--text-dim); max-width: 400px; margin: 0 auto;">
                        æ­£åœ¨åˆ›å»ºè¿·å®«ï¼Œåˆå§‹åŒ–ç²’å­ç³»ç»Ÿï¼Œè¯·ç¨å€™...
                    </p>
                </div>
                
                <div style="width: 100%; max-width: 500px; margin-bottom: 2rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; color: var(--text-dim);">
                        <span id="loadingStep">åˆå§‹åŒ–æ¸¸æˆå¼•æ“</span>
                        <span id="loadingPercent">0%</span>
                    </div>
                    
                    <div style="height: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 6px; overflow: hidden; margin-bottom: 2rem;">
                        <div id="loadingBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, var(--primary-blue), var(--neon-cyan), var(--primary-red)); border-radius: 6px; transition: width 0.5s ease-out;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- åœºæ™¯5: æ¸¸æˆä¸­ -->
        <div id="gameScene" class="scene">
            <div id="gameContainer" style="position: relative; width: 100%; height: 100%; overflow: hidden; background: #000;">
                <!-- æ¸¸æˆç”»å¸ƒ -->
                <canvas id="gameCanvas" style="display: block; background: #000;"></canvas>
                
                <!-- æ¸¸æˆUIè¦†ç›–å±‚ -->
                <div id="gameUI" style="position: absolute; top: 0; left: 0; width: 100%; padding: 1rem; pointer-events: none; z-index: 100;">
                    <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
                        <!-- å·¦ï¼šç©å®¶ä¿¡æ¯ -->
                        <div style="background: rgba(15, 23, 42, 0.85); padding: 0.75rem 1.5rem; border-radius: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(59, 130, 246, 0.5); min-width: 200px; pointer-events: auto;">
                            <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--primary-blue);"></div>
                                <span style="color: white; font-weight: 600;" id="playerName">ç­‰å¾…åˆ†é…</span>
                                <span style="background: rgba(59, 130, 246, 0.2); color: var(--primary-blue); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">ä½ </span>
                            </div>
                            
                            <div style="margin-bottom: 0.5rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem; font-size: 0.9rem; color: var(--text-dim);">
                                    <span>ç”Ÿå‘½å€¼</span>
                                    <span id="playerHP">100</span>
                                </div>
                                <div style="height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                                    <div id="playerHealthBar" style="height: 100%; width: 100%; background: linear-gradient(90deg, var(--primary-blue), #60a5fa); border-radius: 4px; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ä¸­ï¼šæ¸¸æˆçŠ¶æ€ -->
                        <div style="background: rgba(15, 23, 42, 0.85); padding: 0.75rem 1.5rem; border-radius: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; pointer-events: auto;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 0.25rem;" id="gameTimer">90</div>
                            <div style="font-size: 0.9rem; color: var(--text-dim);">å‰©ä½™æ—¶é—´</div>
                            
                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                                <div style="display: flex; justify-content: center; gap: 2rem; color: white; font-weight: 600;">
                                    <span id="playerScore">0</span>
                                    <span style="color: var(--text-dim);">:</span>
                                    <span id="opponentScore">0</span>
                                </div>
                                <div style="font-size: 0.8rem; color: var(--text-dim);">åˆ†æ•°</div>
                            </div>
                        </div>
                        
                        <!-- å³ï¼šå¯¹æ‰‹ä¿¡æ¯ -->
                        <div style="background: rgba(15, 23, 42, 0.85); padding: 0.75rem 1.5rem; border-radius: 12px; backdrop-filter: blur(10px); border: 1px solid rgba(239, 68, 68, 0.5); min-width: 200px; pointer-events: auto;">
                            <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem; justify-content: flex-end;">
                                <span style="background: rgba(239, 68, 68, 0.2); color: var(--primary-red); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">å¯¹æ‰‹</span>
                                <span style="color: white; font-weight: 600;" id="opponentName">å¯¹æ‰‹</span>
                                <div style="width: 12px; height: 12px; border-radius: 50%; background: var(--primary-red);"></div>
                            </div>
                            
                            <div style="margin-bottom: 0.5rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem; font-size: 0.9rem; color: var(--text-dim);">
                                    <span>ç”Ÿå‘½å€¼</span>
                                    <span id="opponentHP">100</span>
                                </div>
                                <div style="height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                                    <div id="opponentHealthBar" style="height: 100%; width: 100%; background: linear-gradient(90deg, var(--primary-red), #f87171); border-radius: 4px; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- è°ƒè¯•ä¿¡æ¯ -->
                    <div id="debugInfo" style="position: absolute; top: 120px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px; font-size: 12px; display: none;">
                        ç›¸æœºä½ç½®: <span id="cameraPos">0,0</span>
                    </div>
                </div>
                
                <!-- æ‰‹æœºæ§åˆ¶æŒ‰é’® -->
                <div id="mobileControls" style="position: absolute; bottom: 0; left: 0; width: 100%; padding: 1rem; display: none; justify-content: space-between; align-items: flex-end; pointer-events: none; z-index: 90;">
                    <!-- å·¦ï¼šç§»åŠ¨æ§åˆ¶ -->
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 8px; width: 150px; height: 150px; pointer-events: auto;">
                        <div style="grid-column: 2; grid-row: 1;">
                            <button class="mobile-btn" data-action="up">
                                <span>â†‘</span>
                            </button>
                        </div>
                        <div style="grid-column: 1; grid-row: 2;">
                            <button class="mobile-btn" data-action="left">
                                <span>â†</span>
                            </button>
                        </div>
                        <div style="grid-column: 2; grid-row: 2;">
                            <button class="mobile-btn" data-action="stop">
                                <span>â—</span>
                            </button>
                        </div>
                        <div style="grid-column: 3; grid-row: 2;">
                            <button class="mobile-btn" data-action="right">
                                <span>â†’</span>
                            </button>
                        </div>
                        <div style="grid-column: 2; grid-row: 3;">
                            <button class="mobile-btn" data-action="down">
                                <span>â†“</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- å³ï¼šæ”»å‡»æ§åˆ¶ -->
                    <div style="display: flex; flex-direction: column; gap: 10px; align-items: center; pointer-events: auto;">
                        <button class="mobile-btn attack-btn" data-action="shoot" style="width: 80px; height: 80px; font-size: 2rem;">
                            <span>âš¡</span>
                        </button>
                        <div style="color: white; font-size: 0.8rem; background: rgba(239, 68, 68, 0.3); padding: 0.3rem 0.8rem; border-radius: 15px;">
                            å‘å°„ç²’å­
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- åœºæ™¯6: æ¸¸æˆç»“æŸ -->
        <div id="gameOverScene" class="scene">
            <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 2rem; text-align: center; background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.9) 100%);">
                <div id="resultContent" style="max-width: 600px; width: 100%;"></div>
                
                <div style="margin-top: 3rem; display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                    <button id="playAgainBtn" class="btn btn-primary" onclick="playAgain()">
                        <span>ğŸ”„</span> å†ç©ä¸€æ¬¡
                    </button>
                    <button id="backToMenuBtn" class="btn btn-secondary" onclick="backToMenu()">
                        <span>ğŸ </span> è¿”å›ä¸»èœå•
                    </button>
                    <button id="shareResultBtn" class="btn btn-secondary" onclick="shareResult()">
                        <span>ğŸ“¤</span> åˆ†äº«ç»“æœ
                    </button>
                </div>
            </div>
        </div>
    </div>

<script>
// ==================== ç¬¬ä¸€éƒ¨åˆ†ï¼šå…¨å±€é”™è¯¯æ•è·å’ŒåŸºç¡€çŠ¶æ€ ====================

window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('ğŸš¨ å…¨å±€JavaScripté”™è¯¯:', msg);
    console.error('ğŸ“ ä½ç½®:', url, lineNo, columnNo);
    if (error) console.error('ğŸ“„ é”™è¯¯å¯¹è±¡:', error);
    
    // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºé”™è¯¯
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = 'position: fixed; top: 10px; left: 10px; background: red; color: white; padding: 10px; z-index: 9999; border-radius: 5px; font-family: monospace;';
    errorDiv.textContent = `é”™è¯¯: ${msg} (è¡Œ${lineNo})`;
    document.body.appendChild(errorDiv);
    
    return false;
};

// æ•è·æœªå¤„ç†çš„Promiseé”™è¯¯
window.addEventListener('unhandledrejection', function(event) {
    console.error('ğŸš¨ æœªå¤„ç†çš„Promiseé”™è¯¯:', event.reason);
});

// ==================== æ¸¸æˆçŠ¶æ€ç®¡ç† ====================
const GameState = {
    MENU: 'menu',
    MATCHING: 'matching',
    LOBBY: 'lobby',
    LOADING: 'loading',
    PLAYING: 'playing',
    GAME_OVER: 'game_over'
};

let currentState = GameState.MENU;
let playerRole = null; // 'proton' æˆ– 'electron'
let matchTimer = 0;
let matchInterval = null;

// ==================== æ¸¸æˆå¼•æ“å˜é‡ ====================
let game = {
    canvas: null,
    ctx: null,
    width: 0,
    height: 0,
    
    // ç›¸æœºç³»ç»Ÿ
    camera: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        zoom: 1,
        targetX: 0,
        targetY: 0,
        smoothness: 0.1,
        // ä¸–ç•Œå°ºå¯¸ï¼ˆæ¸¸æˆå®é™…å¤§å°ï¼Œæ¯”å±å¹•å¤§ï¼‰
        worldWidth: 2000,
        worldHeight: 2000
    },
    
    // æ¸¸æˆçŠ¶æ€
    players: {
        player1: null,
        player2: null
    },
    projectiles: [],
    maze: [],
    mazeCols: 0,
    mazeRows: 0,
    cellSize: 40,
    
    // è¾“å…¥æ§åˆ¶
    keys: {},
    touchControls: {},
    isMobile: false,
    
    // æ¸¸æˆè®¡æ—¶
    gameTime: 90,
    gameTimer: null,
    lastUpdateTime: 0,
    
    // æ¸¸æˆçŠ¶æ€
    isGameActive: false,
    playerScore: 0,
    opponentScore: 0,
    mazeSeed: 0,
    
    // è°ƒè¯•ä¿¡æ¯
    loopCounter: 0,
    lastLoopTime: 0,
    
    // æ˜¯å¦æ˜¯å¤šäººæ¸¸æˆ
    isMultiplayer: false,
    isConnectedToOpponent: false
};

// ==================== ç›¸æœºç³»ç»Ÿ ====================
function initializeCamera() {
    console.log('ğŸ“· åˆå§‹åŒ–ç›¸æœºç³»ç»Ÿ');
    
    // è®¾ç½®ç›¸æœºå°ºå¯¸ä¸ºå±å¹•å°ºå¯¸
    game.camera.width = game.width;
    game.camera.height = game.height;
    
    // è®¾ç½®ä¸–ç•Œå°ºå¯¸ä¸ºå±å¹•çš„3å€ï¼Œä¿è¯æœ‰è¶³å¤Ÿçš„æ¢ç´¢ç©ºé—´
    game.camera.worldWidth = game.width * 3;
    game.camera.worldHeight = game.height * 3;
    
    // åˆå§‹ä½ç½®åœ¨ä¸–ç•Œä¸­å¿ƒ
    game.camera.x = game.camera.worldWidth / 2 - game.camera.width / 2;
    game.camera.y = game.camera.worldHeight / 2 - game.camera.height / 2;
    game.camera.targetX = game.camera.x;
    game.camera.targetY = game.camera.y;
    
    console.log(`ç›¸æœºåˆå§‹åŒ–: å±å¹•${game.width}x${game.height}, ä¸–ç•Œ${game.camera.worldWidth}x${game.camera.worldHeight}`);
}

function updateCamera(player) {
    if (!player || !game.isGameActive) return;
    
    // ç›®æ ‡ä½ç½®ï¼šç©å®¶åœ¨å±å¹•ä¸­å¿ƒ
    game.camera.targetX = player.x - game.camera.width / 2;
    game.camera.targetY = player.y - game.camera.height / 2;
    
    // é™åˆ¶ç›¸æœºåœ¨ä¸–ç•ŒèŒƒå›´å†…
    game.camera.targetX = Math.max(0, Math.min(game.camera.worldWidth - game.camera.width, game.camera.targetX));
    game.camera.targetY = Math.max(0, Math.min(game.camera.worldHeight - game.camera.height, game.camera.targetY));
    
    // å¹³æ»‘ç§»åŠ¨ç›¸æœº
    game.camera.x += (game.camera.targetX - game.camera.x) * game.camera.smoothness;
    game.camera.y += (game.camera.targetY - game.camera.y) * game.camera.smoothness;
    
    // æ›´æ–°è°ƒè¯•ä¿¡æ¯
    if (document.getElementById('cameraPos')) {
        document.getElementById('cameraPos').textContent = 
            `${Math.round(game.camera.x)},${Math.round(game.camera.y)}`;
    }
}

// åæ ‡è½¬æ¢å‡½æ•°
function worldToScreen(x, y) {
    return {
        x: x - game.camera.x,
        y: y - game.camera.y
    };
}

function screenToWorld(x, y) {
    return {
        x: x + game.camera.x,
        y: y + game.camera.y
    };
}

// ==================== åœºæ™¯åˆ‡æ¢ ====================
function switchScene(sceneId) {
    console.log(`ğŸ”„ åˆ‡æ¢åœºæ™¯åˆ°: ${sceneId}`);
    
    // éšè—æ‰€æœ‰åœºæ™¯
    document.querySelectorAll('.scene').forEach(scene => {
        scene.classList.remove('active');
    });
    
    // æ˜¾ç¤ºç›®æ ‡åœºæ™¯
    const targetScene = document.getElementById(sceneId);
    if (targetScene) {
        targetScene.classList.add('active');
    } else {
        console.error(`âŒ æ‰¾ä¸åˆ°åœºæ™¯: ${sceneId}`);
    }
    
    // æ›´æ–°çŠ¶æ€
    currentState = sceneId.replace('Scene', '').toUpperCase();
    console.log(`âœ… å½“å‰çŠ¶æ€: ${currentState}`);
}
// ==================== ç²’å­ç³»ç»Ÿ ====================
function shootProjectile(shooter) {
    console.log('ğŸ”« å‘å°„ç²’å­ï¼Œå‘å°„è€…:', shooter === game.players.player1 ? 'ç©å®¶' : 'å¯¹æ‰‹');
    
    const projectile = {
        id: Date.now() + Math.random(), // å”¯ä¸€ID
        x: shooter.x,
        y: shooter.y,
        radius: 6,
        color: shooter.color,
        speed: 8,
        direction: shooter.direction,
        dx: Math.cos(shooter.direction) * 8,
        dy: Math.sin(shooter.direction) * 8,
        owner: shooter === game.players.player1 ? 'player1' : 'player2',
        shooterId: shooter === game.players.player1 ? 'player1' : 'player2',
        bounceCount: 3,
        lifeTime: 5000,
        active: true
    };
    
    game.projectiles.push(projectile);
    console.log('âœ… ç²’å­å·²åˆ›å»ºï¼Œæ–¹å‘:', shooter.direction);
    
    // æ’­æ”¾å°„å‡»éŸ³æ•ˆ
    playSound('shoot');
}

function updateProjectiles(deltaTime) {
    if (!game.isGameActive) return;
    
    for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const p = game.projectiles[i];
        
        if (!p.active) {
            game.projectiles.splice(i, 1);
            continue;
        }
        
        // æ›´æ–°ä½ç½®
        p.x += p.dx;
        p.y += p.dy;
        
        // å‡å°‘å¯¿å‘½
        p.lifeTime -= deltaTime;
        if (p.lifeTime <= 0) {
            game.projectiles.splice(i, 1);
            continue;
        }
        
        // æ£€æŸ¥å¢™å£ç¢°æ’
        if (checkWallCollision(p.x, p.y, p.radius)) {
            // è®¡ç®—åå¼¹
            const normal = getWallNormal(p.x, p.y);
            if (normal) {
                // åå°„å…¬å¼: R = V - 2*(VÂ·N)*N
                const dot = p.dx * normal.x + p.dy * normal.y;
                
                // æ›´æ–°é€Ÿåº¦åˆ†é‡
                p.dx = p.dx - 2 * dot * normal.x;
                p.dy = p.dy - 2 * dot * normal.y;
                
                p.bounceCount--;
                
                // æ’­æ”¾éŸ³æ•ˆ
                playSound('bounce');
            }
            
            if (p.bounceCount <= 0) {
                game.projectiles.splice(i, 1);
                continue;
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦é£å‡ºä¸–ç•Œè¾¹ç•Œ
        if (p.x < -100 || p.x > game.camera.worldWidth + 100 || 
            p.y < -100 || p.y > game.camera.worldHeight + 100) {
            game.projectiles.splice(i, 1);
        }
    }
}

function getWallNormal(x, y) {
    const cellX = Math.floor(x / game.cellSize);
    const cellY = Math.floor(y / game.cellSize);
    
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const checkX = cellX + dx;
            const checkY = cellY + dy;
            
            if (checkX >= 0 && checkX < game.mazeCols &&
                checkY >= 0 && checkY < game.mazeRows &&
                game.maze[checkY][checkX] === 1) {
                
                const wallCenterX = (checkX + 0.5) * game.cellSize;
                const wallCenterY = (checkY + 0.5) * game.cellSize;
                
                const dxToCenter = x - wallCenterX;
                const dyToCenter = y - wallCenterY;
                
                // è®¡ç®—æ³•çº¿ï¼ˆä»å¢™å£ä¸­å¿ƒæŒ‡å‘ç¢°æ’ç‚¹ï¼‰
                const distance = Math.sqrt(dxToCenter * dxToCenter + dyToCenter * dyToCenter);
                
                return {
                    x: dxToCenter / distance,
                    y: dyToCenter / distance
                };
            }
        }
    }
    return null;
}

// ==================== ç¢°æ’æ£€æµ‹ ====================
function checkCollisions() {
    // æ£€æŸ¥å­å¼¹ä¸ç©å®¶çš„ç¢°æ’
    for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const p = game.projectiles[i];
        
        for (const [playerKey, player] of Object.entries(game.players)) {
            if (p.shooterId !== playerKey && player && player.hp > 0) {
                const distance = Math.sqrt(
                    Math.pow(p.x - player.x, 2) + Math.pow(p.y - player.y, 2)
                );
                
                if (distance < p.radius + player.radius) {
                    console.log(`ğŸ’¥ å‡»ä¸­ ${playerKey}ï¼`);
                    
                    // å‡»ä¸­ç©å®¶
                    player.hp -= 25;
                    
                    // æ›´æ–°åˆ†æ•°
                    if (p.owner === 'player1') {
                        game.players.player1.score += 10;
                        game.playerScore = game.players.player1.score;
                    } else {
                        game.players.player2.score += 10;
                        game.opponentScore = game.players.player2.score;
                    }
                    
                    // æ›´æ–°UI
                    updateHealthBars();
                    updateScores();
                    
                    // ç§»é™¤å­å¼¹
                    game.projectiles.splice(i, 1);
                    
                    // æ’­æ”¾å‡»ä¸­éŸ³æ•ˆ
                    playSound('hit');
                    
                    // å¦‚æœæ˜¯å¤šäººæ¸¸æˆï¼Œå‘é€å‡»ä¸­äº‹ä»¶
                    if (game.isMultiplayer && window.MultiplayerGame) {
                        window.MultiplayerGame.sendHitAction(playerKey, p);
                    }
                    
                    // æ£€æŸ¥æ¸¸æˆç»“æŸ
                    if (player.hp <= 0) {
                        player.hp = 0;
                        console.log(`ğŸ® æ¸¸æˆç»“æŸï¼${p.owner === 'player1' ? 'ç©å®¶' : 'å¯¹æ‰‹'}è·èƒœ`);
                        endGame(p.owner === 'player1' ? 'player1' : 'player2');
                    }
                    
                    break;
                }
            }
        }
    }
}

function updateHealthBars() {
    const playerHealthBar = document.getElementById('playerHealthBar');
    const opponentHealthBar = document.getElementById('opponentHealthBar');
    const playerHP = document.getElementById('playerHP');
    const opponentHP = document.getElementById('opponentHP');
    
    if (playerHealthBar && game.players.player1) {
        const percent = (game.players.player1.hp / game.players.player1.maxHp) * 100;
        playerHealthBar.style.width = `${percent}%`;
        if (playerHP) playerHP.textContent = game.players.player1.hp;
    }
    
    if (opponentHealthBar && game.players.player2) {
        const percent = (game.players.player2.hp / game.players.player2.maxHp) * 100;
        opponentHealthBar.style.width = `${percent}%`;
        if (opponentHP) opponentHP.textContent = game.players.player2.hp;
    }
}

function updateScores() {
    const playerScoreElement = document.getElementById('playerScore');
    const opponentScoreElement = document.getElementById('opponentScore');
    
    if (playerScoreElement) {
        playerScoreElement.textContent = game.playerScore;
    }
    
    if (opponentScoreElement) {
        opponentScoreElement.textContent = game.opponentScore;
    }
}

// ==================== æ¸¸æˆæ¸²æŸ“ ====================
function renderGame() {
    if (!game.ctx || !game.canvas) {
        console.error('âŒ æ— æ³•æ¸²æŸ“ï¼šç”»å¸ƒä¸Šä¸‹æ–‡ä¸å­˜åœ¨');
        return;
    }
    
    // æ¸…ç©ºç”»å¸ƒ
    game.ctx.fillStyle = '#000000';
    game.ctx.fillRect(0, 0, game.width, game.height);
    
    // ä¿å­˜ä¸Šä¸‹æ–‡çŠ¶æ€
    game.ctx.save();
    
    // åº”ç”¨ç›¸æœºå˜æ¢
    game.ctx.translate(-game.camera.x, -game.camera.y);
    
    // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼ï¼ˆä»…åœ¨å¼€å‘æ—¶æ˜¾ç¤ºï¼‰
    if (false) { // è®¾ç½®ä¸ºtrueæ˜¾ç¤ºè°ƒè¯•ç½‘æ ¼
        drawDebugGrid();
    }
    
    // ç»˜åˆ¶è¿·å®«
    drawMaze();
    
    // ç»˜åˆ¶ç©å®¶
    drawPlayer(game.players.player1);
    drawPlayer(game.players.player2);
    
    // ç»˜åˆ¶å­å¼¹
    drawProjectiles();
    
    // ç»˜åˆ¶æ–¹å‘æŒ‡ç¤ºå™¨
    drawDirectionIndicators();
    
    // æ¢å¤ä¸Šä¸‹æ–‡çŠ¶æ€
    game.ctx.restore();
    
    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
    if (document.getElementById('debugInfo') && document.getElementById('debugInfo').style.display !== 'none') {
        drawDebugInfo();
    }
}

function drawDebugGrid() {
    const worldWidth = game.camera.worldWidth;
    const worldHeight = game.camera.worldHeight;
    
    // ç»˜åˆ¶ç½‘æ ¼çº¿
    game.ctx.strokeStyle = '#222222';
    game.ctx.lineWidth = 1;
    
    // å‚ç›´çº¿
    for (let x = 0; x <= worldWidth; x += 50) {
        game.ctx.beginPath();
        game.ctx.moveTo(x, 0);
        game.ctx.lineTo(x, worldHeight);
        game.ctx.stroke();
    }
    
    // æ°´å¹³çº¿
    for (let y = 0; y <= worldHeight; y += 50) {
        game.ctx.beginPath();
        game.ctx.moveTo(0, y);
        game.ctx.lineTo(worldWidth, y);
        game.ctx.stroke();
    }
    
    // ç»˜åˆ¶ä¸–ç•Œè¾¹ç•Œ
    game.ctx.strokeStyle = '#ff0000';
    game.ctx.lineWidth = 2;
    game.ctx.strokeRect(0, 0, worldWidth, worldHeight);
}

function drawMaze() {
    const worldWidth = game.camera.worldWidth;
    const worldHeight = game.camera.worldHeight;
    
    // è®¡ç®—å¯è§åŒºåŸŸï¼ˆä¼˜åŒ–æ¸²æŸ“ï¼‰
    const visibleLeft = game.camera.x;
    const visibleRight = game.camera.x + game.camera.width;
    const visibleTop = game.camera.y;
    const visibleBottom = game.camera.y + game.camera.height;
    
    // è®¡ç®—å¯è§çš„ç½‘æ ¼èŒƒå›´
    const startCol = Math.max(0, Math.floor(visibleLeft / game.cellSize) - 1);
    const endCol = Math.min(game.mazeCols, Math.ceil(visibleRight / game.cellSize) + 1);
    const startRow = Math.max(0, Math.floor(visibleTop / game.cellSize) - 1);
    const endRow = Math.min(game.mazeRows, Math.ceil(visibleBottom / game.cellSize) + 1);
    
    game.ctx.fillStyle = '#334155';
    
    for (let y = startRow; y < endRow; y++) {
        for (let x = startCol; x < endCol; x++) {
            if (game.maze[y][x] === 1) {
                const wallX = x * game.cellSize;
                const wallY = y * game.cellSize;
                
                // ç»˜åˆ¶å¢™å£
                game.ctx.fillRect(wallX, wallY, game.cellSize, game.cellSize);
                
                // å¢™å£è¾¹æ¡†
                game.ctx.strokeStyle = '#475569';
                game.ctx.lineWidth = 2;
                game.ctx.strokeRect(wallX, wallY, game.cellSize, game.cellSize);
                
                // å¢™å£çº¹ç†
                game.ctx.fillStyle = '#1e293b';
                game.ctx.fillRect(wallX + 2, wallY + 2, game.cellSize - 4, game.cellSize - 4);
                
                // æ¢å¤å¡«å……é¢œè‰²
                game.ctx.fillStyle = '#334155';
            }
        }
    }
}

function drawPlayer(player) {
    if (!player || player.hp <= 0) return;
    
    // è½¬æ¢ä¸ºå±å¹•åæ ‡
    const screenPos = worldToScreen(player.x, player.y);
    
    // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å±å¹•ä¸Š
    if (screenPos.x < -50 || screenPos.x > game.width + 50 || 
        screenPos.y < -50 || screenPos.y > game.height + 50) {
        return; // ä¸åœ¨å±å¹•å†…ï¼Œä¸æ¸²æŸ“
    }
    
    // ç©å®¶å…‰æ™•æ•ˆæœ
    const gradient = game.ctx.createRadialGradient(
        player.x, player.y, 0,
        player.x, player.y, player.radius * 3
    );
    gradient.addColorStop(0, `${player.color}40`);
    gradient.addColorStop(1, `${player.color}00`);
    
    game.ctx.fillStyle = gradient;
    game.ctx.beginPath();
    game.ctx.arc(player.x, player.y, player.radius * 3, 0, Math.PI * 2);
    game.ctx.fill();
    
    // ç©å®¶ä¸»ä½“
    game.ctx.fillStyle = player.color;
    game.ctx.beginPath();
    game.ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    game.ctx.fill();
    
    // ç©å®¶è¾¹æ¡†
    game.ctx.strokeStyle = player.isLocalPlayer ? '#ffffff' : '#cccccc';
    game.ctx.lineWidth = player.isLocalPlayer ? 2 : 1.5;
    game.ctx.beginPath();
    game.ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    game.ctx.stroke();
    
    // è¡€é‡ç¯
    const hpPercent = player.hp / player.maxHp;
    game.ctx.strokeStyle = hpPercent > 0.5 ? '#10b981' : hpPercent > 0.25 ? '#f59e0b' : '#ef4444';
    game.ctx.lineWidth = 3;
    game.ctx.beginPath();
    game.ctx.arc(player.x, player.y, player.radius + 3, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * hpPercent);
    game.ctx.stroke();
    
    // è§’è‰²æ ‡è¯†
    game.ctx.fillStyle = '#ffffff';
    game.ctx.font = 'bold 14px Arial';
    game.ctx.textAlign = 'center';
    game.ctx.textBaseline = 'middle';
    
    let symbol = '';
    if (player.color === '#3b82f6') {
        symbol = player.isLocalPlayer ? 'Pâº' : 'P';
    } else {
        symbol = player.isLocalPlayer ? 'Eâ»' : 'E';
    }
    
    game.ctx.fillText(symbol, player.x, player.y);
    
    // å¦‚æœæ˜¯æœ¬åœ°ç©å®¶ï¼Œæ·»åŠ ç‰¹æ®Šæ•ˆæœ
    if (player.isLocalPlayer) {
        game.ctx.strokeStyle = '#ffffff';
        game.ctx.lineWidth = 1;
        game.ctx.setLineDash([5, 5]);
        game.ctx.beginPath();
        game.ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
        game.ctx.stroke();
        game.ctx.setLineDash([]);
    }
}

function drawProjectiles() {
    game.projectiles.forEach((p) => {
        // æ£€æŸ¥ç²’å­æ˜¯å¦åœ¨å±å¹•ä¸Š
        const screenPos = worldToScreen(p.x, p.y);
        if (screenPos.x < -100 || screenPos.x > game.width + 100 || 
            screenPos.y < -100 || screenPos.y > game.height + 100) {
            return; // ä¸åœ¨å±å¹•å†…ï¼Œä¸æ¸²æŸ“
        }
        
        // å­å¼¹è½¨è¿¹
        game.ctx.strokeStyle = `${p.color}40`;
        game.ctx.lineWidth = 1;
        game.ctx.beginPath();
        game.ctx.moveTo(p.x - Math.cos(p.direction) * 10, p.y - Math.sin(p.direction) * 10);
        game.ctx.lineTo(p.x, p.y);
        game.ctx.stroke();
        
        // å­å¼¹å…‰æ™•
        const gradient = game.ctx.createRadialGradient(
            p.x, p.y, 0,
            p.x, p.y, p.radius * 3
        );
        gradient.addColorStop(0, `${p.color}80`);
        gradient.addColorStop(1, `${p.color}00`);
        
        game.ctx.fillStyle = gradient;
        game.ctx.beginPath();
        game.ctx.arc(p.x, p.y, p.radius * 3, 0, Math.PI * 2);
        game.ctx.fill();
        
        // å­å¼¹ä¸»ä½“
        game.ctx.fillStyle = p.color;
        game.ctx.beginPath();
        game.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        game.ctx.fill();
        
        // å­å¼¹é«˜å…‰
        game.ctx.fillStyle = '#ffffff';
        game.ctx.beginPath();
        game.ctx.arc(
            p.x - Math.cos(p.direction) * p.radius * 0.3,
            p.y - Math.sin(p.direction) * p.radius * 0.3,
            p.radius * 0.4, 0, Math.PI * 2
        );
        game.ctx.fill();
    });
}

function drawDirectionIndicators() {
    // ç»˜åˆ¶æœ¬åœ°ç©å®¶æ–¹å‘æŒ‡ç¤ºå™¨
    if (game.players.player1 && game.players.player1.isLocalPlayer && game.players.player1.hp > 0) {
        drawDirectionIndicator(game.players.player1, '#ffffff');
    }
    
    // ç»˜åˆ¶å¯¹æ‰‹æ–¹å‘æŒ‡ç¤ºå™¨ï¼ˆå¦‚æœå¯è§ï¼‰
    if (game.players.player2 && game.players.player2.hp > 0) {
        const screenPos = worldToScreen(game.players.player2.x, game.players.player2.y);
        if (screenPos.x >= 0 && screenPos.x <= game.width && 
            screenPos.y >= 0 && screenPos.y <= game.height) {
            drawDirectionIndicator(game.players.player2, '#cccccc');
        }
    }
}

function drawDirectionIndicator(player, color) {
    game.ctx.strokeStyle = color;
    game.ctx.lineWidth = 2;
    game.ctx.beginPath();
    game.ctx.moveTo(player.x, player.y);
    game.ctx.lineTo(
        player.x + Math.cos(player.direction) * (player.radius + 20),
        player.y + Math.sin(player.direction) * (player.radius + 20)
    );
    game.ctx.stroke();
    
    // ç®­å¤´å¤´
    game.ctx.fillStyle = color;
    game.ctx.beginPath();
    game.ctx.arc(
        player.x + Math.cos(player.direction) * (player.radius + 20),
        player.y + Math.sin(player.direction) * (player.radius + 20),
        4, 0, Math.PI * 2
    );
    game.ctx.fill();
}

function drawDebugInfo() {
    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯ï¼ˆä¸–ç•Œåæ ‡ï¼‰
    game.ctx.fillStyle = '#ffffff';
    game.ctx.font = '14px Arial';
    game.ctx.textAlign = 'left';
    game.ctx.textBaseline = 'top';
    
    // è½¬æ¢å›å±å¹•åæ ‡
    game.ctx.save();
    game.ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®å˜æ¢
    
    const player1Pos = worldToScreen(game.players.player1?.x || 0, game.players.player1?.y || 0);
    const player2Pos = worldToScreen(game.players.player2?.x || 0, game.players.player2?.y || 0);
    
    game.ctx.fillText(`æ¸¸æˆå¾ªç¯: ${loopFrameCount}`, 10, 10);
    game.ctx.fillText(`ç²’å­æ•°é‡: ${game.projectiles.length}`, 10, 30);
    game.ctx.fillText(`ç©å®¶ä½ç½®: (${Math.round(game.players.player1?.x || 0)}, ${Math.round(game.players.player1?.y || 0)})`, 10, 50);
    game.ctx.fillText(`å¯¹æ‰‹ä½ç½®: (${Math.round(game.players.player2?.x || 0)}, ${Math.round(game.players.player2?.y || 0)})`, 10, 70);
    game.ctx.fillText(`ç›¸æœºä½ç½®: (${Math.round(game.camera.x)}, ${Math.round(game.camera.y)})`, 10, 90);
    game.ctx.fillText(`æ¸¸æˆæ¨¡å¼: ${game.isMultiplayer ? 'å¤šäººæ¸¸æˆ' : 'å•äººæ¸¸æˆ'}`, 10, 110);
    
    game.ctx.restore();
}

// ==================== æ¸¸æˆè®¡æ—¶å™¨ ====================
function startGameTimer() {
    console.log('â±ï¸ å¯åŠ¨æ¸¸æˆè®¡æ—¶å™¨...');
    
    if (game.gameTimer) {
        clearInterval(game.gameTimer);
    }
    
    game.gameTimer = setInterval(() => {
        if (!game.isGameActive) return;
        
        game.gameTime--;
        const gameTimerElement = document.getElementById('gameTimer');
        if (gameTimerElement) {
            gameTimerElement.textContent = game.gameTime;
        }
        
        if (game.gameTime <= 0) {
            clearInterval(game.gameTimer);
            console.log('â° æ—¶é—´åˆ°ï¼æ¸¸æˆç»“æŸ');
            endGame('timeout');
        }
    }, 1000);
    
    console.log('âœ… æ¸¸æˆè®¡æ—¶å™¨å·²å¯åŠ¨');
}

// ==================== éŸ³æ•ˆç³»ç»Ÿ ====================
function playSound(type) {
    // è¿™é‡Œå¯ä»¥æ·»åŠ çœŸæ­£çš„éŸ³é¢‘æ’­æ”¾
    const sounds = {
        shoot: 'ğŸ”«',
        bounce: 'â†ªï¸',
        hit: 'ğŸ’¥',
        win: 'ğŸ†',
        lose: 'ğŸ’€'
    };
    
    console.log(`${sounds[type] || 'ğŸ”Š'} æ’­æ”¾éŸ³æ•ˆ: ${type}`);
}

// ==================== æ¸¸æˆç»“æŸé€»è¾‘ ====================
function endGame(winner) {
    console.log(`ğŸ® æ¸¸æˆç»“æŸï¼Œèƒœåˆ©è€…: ${winner}`);
    
    game.isGameActive = false;
    
    if (game.gameTimer) {
        clearInterval(game.gameTimer);
        game.gameTimer = null;
    }
    
    // è®¡ç®—èƒœåˆ©è€…
    let gameResult = {
        winner: winner,
        playerScore: game.playerScore,
        opponentScore: game.opponentScore,
        playerHP: game.players.player1 ? game.players.player1.hp : 0,
        opponentHP: game.players.player2 ? game.players.player2.hp : 0,
        timeLeft: game.gameTime
    };
    
    // å¦‚æœæ˜¯è¶…æ—¶ï¼Œæ ¹æ®è¡€é‡åˆ¤æ–­èƒœè´Ÿ
    if (winner === 'timeout') {
        if (gameResult.playerHP > gameResult.opponentHP) {
            gameResult.winner = 'player1';
        } else if (gameResult.playerHP < gameResult.opponentHP) {
            gameResult.winner = 'player2';
        } else {
            gameResult.winner = 'draw';
        }
    }
    
    // ä¿å­˜ç»“æœ
    localStorage.setItem('lastGameResult', JSON.stringify(gameResult));
    console.log('ğŸ’¾ æ¸¸æˆç»“æœå·²ä¿å­˜:', gameResult);
    
    // å¦‚æœæ˜¯å¤šäººæ¸¸æˆï¼Œå‘é€æ¸¸æˆç»“æŸäº‹ä»¶
    if (game.isMultiplayer && window.MultiplayerGame) {
        window.MultiplayerGame.sendGameOver(gameResult.winner);
    }
    
    // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
    setTimeout(() => {
        switchScene('gameOverScene');
        showGameResult(gameResult);
    }, 1000);
}

// ==================== æ¸¸æˆç»“æœå±•ç¤º ====================
function showGameResult(result) {
    const resultContent = document.getElementById('resultContent');
    if (!resultContent) return;
    
    let title = '';
    let message = '';
    let icon = '';
    let color = '';
    
    // åˆ¤æ–­èƒœè´Ÿ
    if (result.winner === 'player1') {
        title = 'ğŸ† èƒœåˆ©ï¼';
        message = 'ä½ å‡»è´¥äº†å¯¹æ‰‹ï¼é‡å­éœ¸æƒå±äºä½ ï¼';
        icon = 'ğŸ‰';
        color = '#10b981';
    } else if (result.winner === 'player2') {
        title = 'ğŸ’€ å¤±è´¥';
        message = 'ä½ è¢«å¯¹æ‰‹å‡»è´¥äº†ï¼Œç»§ç»­åŠªåŠ›ï¼';
        icon = 'ğŸ˜¢';
        color = '#ef4444';
    } else if (result.winner === 'draw') {
        title = 'ğŸ¤ å¹³å±€ï¼';
        message = 'åŠ¿å‡åŠ›æ•Œï¼ä¸‹æ¬¡å†æˆ˜ï¼';
        icon = 'âš–ï¸';
        color = '#f59e0b';
    }
    
    // ç”Ÿæˆç»“æœHTML
    resultContent.innerHTML = `
        <div style="background: rgba(255, 255, 255, 0.05); border-radius: 20px; padding: 3rem 2rem; border: 3px solid ${color}; margin-bottom: 2rem; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);">
            <div style="font-size: 5rem; margin-bottom: 1rem; animation: float 2s ease-in-out infinite;">${icon}</div>
            
            <h1 style="font-size: 3rem; margin-bottom: 1rem; color: ${color};">${title}</h1>
            
            <p style="color: var(--text-dim); font-size: 1.1rem; margin-bottom: 2rem; max-width: 400px; margin-left: auto; margin-right: auto;">${message}</p>
            
            <div style="display: flex; justify-content: center; gap: 3rem; margin: 2rem 0; flex-wrap: wrap;">
                <div style="text-align: center;">
                    <div style="font-size: 2.5rem; color: ${playerRole === 'proton' ? '#3b82f6' : '#ef4444'}; font-weight: bold;">${result.playerScore}</div>
                    <div style="color: var(--text-dim); margin-top: 0.5rem;">ä½ çš„åˆ†æ•°</div>
                </div>
                
                <div style="text-align: center;">
                    <div style="font-size: 2.5rem; color: ${playerRole === 'proton' ? '#ef4444' : '#3b82f6'}; font-weight: bold;">${result.opponentScore}</div>
                    <div style="color: var(--text-dim); margin-top: 0.5rem;">å¯¹æ‰‹åˆ†æ•°</div>
                </div>
            </div>
            
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 1.5rem; margin-top: 2rem;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                    <span style="color: var(--text-dim);">è§’è‰²</span>
                    <span style="color: white; font-weight: bold;">${playerRole === 'proton' ? 'è´¨å­ (è“è‰²)' : 'ç”µå­ (çº¢è‰²)'}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                    <span style="color: var(--text-dim);">å‰©ä½™è¡€é‡</span>
                    <span style="color: white; font-weight: bold;">${result.playerHP} / 100</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: var(--text-dim);">æ¸¸æˆæ—¶é•¿</span>
                    <span style="color: white; font-weight: bold;">${90 - result.timeLeft} ç§’</span>
                </div>
            </div>
        </div>
        
        <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem;">
            <h4 style="color: white; margin-bottom: 0.75rem;">ğŸ“Š æ¸¸æˆç»Ÿè®¡</h4>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; text-align: left;">
                <div>
                    <div style="color: var(--text-dim); font-size: 0.9rem;">æ€»åˆ†æ•°</div>
                    <div style="color: white; font-size: 1.5rem; font-weight: bold;" id="totalScore">${result.playerScore + result.opponentScore}</div>
                </div>
                <div>
                    <div style="color: var(--text-dim); font-size: 0.9rem;">å‰©ä½™æ—¶é—´</div>
                    <div style="color: white; font-size: 1.5rem; font-weight: bold;" id="timeLeft">${result.timeLeft}s</div>
                </div>
                <div>
                    <div style="color: var(--text-dim); font-size: 0.9rem;">å‡†ç¡®ç‡</div>
                    <div style="color: white; font-size: 1.5rem; font-weight: bold;" id="accuracy">${result.playerScore > 0 ? Math.round((result.playerScore / (result.playerScore + result.opponentScore)) * 100) : 0}%</div>
                </div>
                <div>
                    <div style="color: var(--text-dim); font-size: 0.9rem;">è·å¾—ç§¯åˆ†</div>
                    <div style="color: #10b981; font-size: 1.5rem; font-weight: bold;" id="pointsEarned">+${calculatePointsEarned(result)}</div>
                </div>
            </div>
        </div>
    `;
    
    // æ’­æ”¾ç›¸åº”éŸ³æ•ˆ
    if (result.winner === 'player1') {
        playSound('win');
    } else {
        playSound('lose');
    }
}

function calculatePointsEarned(result) {
    let points = 0;
    if (result.winner === 'player1') {
        points = 25 + Math.floor(result.playerScore / 10);
    } else if (result.winner === 'player2') {
        points = 5 + Math.floor(result.playerScore / 20);
    } else {
        points = 10 + Math.floor(result.playerScore / 15);
    }
    savePoints(points);
    return points;
}

function savePoints(points) {
    try {
        let totalPoints = localStorage.getItem('gamePoints');
        totalPoints = totalPoints ? parseInt(totalPoints) : 0;
        totalPoints += points;
        localStorage.setItem('gamePoints', totalPoints);
        console.log(`ğŸ’° è·å¾— ${points} ç§¯åˆ†ï¼Œæ€»ç§¯åˆ†: ${totalPoints}`);
    } catch (error) {
        console.error('âŒ ä¿å­˜ç§¯åˆ†æ—¶å‡ºé”™:', error);
    }
}

// ==================== æ¸¸æˆç»“æŸæ“ä½œ ====================
function playAgain() {
    console.log('ğŸ”„ é‡æ–°å¼€å§‹æ¸¸æˆ');
    resetGame();
    
    if (game.isMultiplayer && window.MultiplayerGame) {
        // å¤šäººæ¸¸æˆï¼šé‡æ–°åŒ¹é…
        startMatchmaking();
    } else {
        // å•äººæ¸¸æˆï¼šç›´æ¥å¼€å§‹
        switchScene('menuScene');
    }
}

function backToMenu() {
    console.log('ğŸ  è¿”å›ä¸»èœå•');
    resetGame();
    switchScene('menuScene');
}

function shareResult() {
    const result = JSON.parse(localStorage.getItem('lastGameResult') || '{}');
    
    let shareText = '';
    if (result.winner === 'player1') {
        shareText = `ğŸ† æˆ‘åœ¨ã€Šè´¨å­VSç”µå­ã€‹ä¸­è·èƒœï¼\n`;
    } else if (result.winner === 'player2') {
        shareText = `ğŸ’ª æˆ‘åœ¨ã€Šè´¨å­VSç”µå­ã€‹ä¸­åŠªåŠ›å¯¹æˆ˜ï¼\n`;
    } else {
        shareText = `âš¡ æˆ‘åœ¨ã€Šè´¨å­VSç”µå­ã€‹ä¸­æ‰“æˆå¹³å±€ï¼\n`;
    }
    
    shareText += `å¾—åˆ†: ${result.playerScore} - ${result.opponentScore}\n`;
    shareText += `å‰©ä½™è¡€é‡: ${result.playerHP}/100\n`;
    shareText += `è§’è‰²: ${playerRole === 'proton' ? 'è´¨å­' : 'ç”µå­'}\n`;
    shareText += `æ¸¸æˆæ—¶é•¿: ${90 - result.timeLeft}ç§’\n`;
    shareText += `\næ¥æŒ‘æˆ˜æˆ‘å§ï¼`;
    
    if (navigator.share) {
        navigator.share({
            title: 'è´¨å­VSç”µå­ - æ¸¸æˆç»“æœ',
            text: shareText
        }).catch(console.error);
    } else {
        navigator.clipboard.writeText(shareText).then(() => {
            alert('ç»“æœå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
        }).catch(() => {
            const textArea = document.createElement('textarea');
            textArea.value = shareText;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            alert('ç»“æœå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
        });
    }
}

function resetGame() {
    console.log('ğŸ”„ é‡ç½®æ¸¸æˆçŠ¶æ€');
    game.isGameActive = false;
    game.isMultiplayer = false;
    game.isConnectedToOpponent = false;
    
    if (game.gameTimer) {
        clearInterval(game.gameTimer);
        game.gameTimer = null;
    }
    
    game.players = { player1: null, player2: null };
    game.projectiles = [];
    game.playerScore = 0;
    game.opponentScore = 0;
    game.gameTime = 90;
    game.keys = {};
    game.touchControls = {};
    loopFrameCount = 0;
    
    console.log('âœ… æ¸¸æˆå·²é‡ç½®');
}
<script>
// ==================== å¤šäººå®æ—¶å¯¹æˆ˜ç³»ç»Ÿï¼ˆä¿®å¤ç‰ˆï¼‰ ====================

// Supabaseé…ç½®ï¼ˆç¡®ä¿åªå®šä¹‰ä¸€æ¬¡ï¼‰
if (!window.SUPABASE_CONFIG) {
    window.SUPABASE_CONFIG = {
        url: 'https://hxvpzskevjxkjmnsorcu.supabase.co',
        anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh4dnB6c2tldmp4a2ptbnNvcmN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk4MTAyNjgsImV4cCI6MjA4NTM4NjI2OH0.pZRITqs0y2HK2NbOPY8PjAxGniq16hGHBWvgm7VtO2E'
    };
}

// æ¸…ç†æ—§çš„ localStorage ID
function cleanupOldIds() {
    const oldPlayerId = localStorage.getItem('player_id');
    const oldClientId = localStorage.getItem('multiplayer_client_id');
    
    if (oldPlayerId && oldPlayerId.startsWith('player_')) {
        localStorage.removeItem('player_id');
        console.log('æ¸…ç†æ—§çš„ player_id:', oldPlayerId);
    }
    
    if (oldClientId && oldClientId.startsWith('client_')) {
        localStorage.removeItem('multiplayer_client_id');
        console.log('æ¸…ç†æ—§çš„ client_id:', oldClientId);
    }
}

// ç”ŸæˆUUIDå‡½æ•°
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0.8);
        return v.toString(16);
    });
}

// ç”Ÿæˆç®€å•IDï¼ˆç”¨äºæˆ¿é—´ï¼‰
function generateSimpleId() {
    return Math.random().toString(36).substr(2, 9);
}

const MultiplayerGame = {
    supabase: null,
    playerId: null,
    clientId: null,
    currentRoom: null,
    playerRole: null,
    mazeSeed: null,
    opponentId: null,
    opponentName: null,
    isMatching: false,
    
    // è¿æ¥çŠ¶æ€
    isConnected: false,
    isInitialized: false,
    heartbeatInterval: null,
    initializationPromise: null,
    
    // æ¸¸æˆçŠ¶æ€åŒæ­¥
    isPlayerReady: false,
    opponentReady: false,
    
    // åˆå§‹åŒ–
    async init() {
        console.log('ğŸ® åˆå§‹åŒ–å¤šäººæ¸¸æˆç³»ç»Ÿ');
        
        // é¿å…é‡å¤åˆå§‹åŒ–
        if (this.isInitialized && this.supabase) {
            console.log('å¤šäººæ¸¸æˆç³»ç»Ÿå·²åˆå§‹åŒ–ï¼Œè·³è¿‡é‡å¤åˆå§‹åŒ–');
            return Promise.resolve();
        }
        
        // å¦‚æœæœ‰æ­£åœ¨è¿›è¡Œçš„åˆå§‹åŒ–ï¼Œè¿”å›è¯¥Promise
        if (this.initializationPromise) {
            console.log('æ­£åœ¨åˆå§‹åŒ–ä¸­ï¼Œç­‰å¾…å®Œæˆ...');
            return this.initializationPromise;
        }
        
        this.initializationPromise = (async () => {
            try {
                // æ¸…ç†æ—§çš„ID
                cleanupOldIds();
                
                // æ£€æŸ¥Supabase SDKæ˜¯å¦å·²åŠ è½½
                if (!window.supabase) {
                    await this.loadSupabaseSDK();
                }
                
                // åˆå§‹åŒ–Supabaseå®¢æˆ·ç«¯
                this.supabase = window.supabase.createClient(
                    SUPABASE_CONFIG.url,
                    SUPABASE_CONFIG.anonKey,
                    {
                        realtime: {
                            params: { eventsPerSecond: 20 }
                        }
                    }
                );
                
                // ç”Ÿæˆå®¢æˆ·ç«¯ID
                this.clientId = generateUUID();
                console.log('å®¢æˆ·ç«¯ID:', this.clientId);
                localStorage.setItem('multiplayer_client_id', this.clientId);
                
                // è®¾ç½®ç©å®¶IDï¼ˆè®¿å®¢æ¨¡å¼ï¼‰
                this.playerId = this.getPlayerId();
                
                // åˆ›å»ºè®¿å®¢èµ„æ–™
                await this.createGuestProfile();
                
                // å¯åŠ¨å¿ƒè·³ï¼ˆç®€åŒ–ç‰ˆï¼Œä¸ä¾èµ–å­˜å‚¨è¿‡ç¨‹ï¼‰
                this.startSimpleHeartbeat();
                
                this.isInitialized = true;
                this.isConnected = true;
                console.log('âœ… å¤šäººæ¸¸æˆç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
                
                return true;
                
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                this.initializationPromise = null;
                throw error;
            }
        })();
        
        return this.initializationPromise;
    },
    
    // è·å–ç©å®¶IDï¼ˆè®¿å®¢æ¨¡å¼ï¼‰
    getPlayerId() {
        let playerId = localStorage.getItem('player_id');
        if (!playerId) {
            playerId = 'player_' + generateSimpleId();
            localStorage.setItem('player_id', playerId);
        }
        return playerId;
    },
    
    // è·å–ç©å®¶åç§°
    getPlayerName() {
        return 'ç©å®¶_' + this.playerId.substr(-6);
    },
    
    // åˆ›å»ºè®¿å®¢èµ„æ–™ï¼ˆç®€åŒ–ç‰ˆï¼‰
    async createGuestProfile() {
        try {
            // å°è¯•æ’å…¥ï¼Œå¿½ç•¥é‡å¤é”™è¯¯
            const { error } = await this.supabase
                .from('profiles')
                .upsert({
                    id: this.playerId,
                    username: this.getPlayerName(),
                    elo: 1000,
                    created_at: new Date().toISOString()
                }, { 
                    onConflict: 'id'
                });
            
            if (error) throw error;
            console.log('è®¿å®¢èµ„æ–™åˆ›å»º/æ›´æ–°æˆåŠŸ');
        } catch (error) {
            // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­
            console.log('åˆ›å»ºè®¿å®¢èµ„æ–™:', error.message);
        }
    },
    
    // åŠ è½½SDK
    loadSupabaseSDK() {
        return new Promise((resolve, reject) => {
            if (window.supabase) {
                resolve();
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²åŠ è½½
            const existingScript = document.querySelector('script[src*="supabase-js"]');
            if (existingScript) {
                existingScript.onload = resolve;
                existingScript.onerror = reject;
                return;
            }
            
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js';
            script.onload = () => {
                console.log('Supabase SDKåŠ è½½æˆåŠŸ');
                resolve();
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
    },
    
    // ==================== åŒ¹é…ç³»ç»Ÿ ====================
    
    // å¼€å§‹åŒ¹é…
    async startMatchmaking() {
        console.log('ğŸ” å¼€å§‹åŒ¹é…çœŸäººç©å®¶...');
        
        this.isMatching = true;
        
        try {
            // å…ˆç¡®ä¿å·²åˆå§‹åŒ–
            if (!this.isInitialized) {
                await this.init();
            }
            
            // æ›´æ–°UI
            this.updateMatchmakingUI(1);
            
            // å¯»æ‰¾ç­‰å¾…ä¸­çš„æˆ¿é—´ï¼ˆæœ€å¤šç­‰å¾…30ç§’ï¼‰
            console.log('å¯»æ‰¾å¯ç”¨çš„æ¸¸æˆæˆ¿é—´...');
            const { data: availableRooms, error: roomsError } = await this.supabase
                .from('game_sessions')
                .select('*')
                .eq('status', 'waiting')
                .is('player2_id', null) // ç¡®ä¿æˆ¿é—´åªæœ‰ä¸€ä¸ªäºº
                .limit(1);
            
            if (roomsError) {
                console.error('æŸ¥è¯¢æˆ¿é—´å¤±è´¥:', roomsError);
                throw roomsError;
            }
            
            console.log('å¯ç”¨æˆ¿é—´:', availableRooms);
            
            let roomId = null;
            let isRoomCreator = true;
            
            if (availableRooms && availableRooms.length > 0) {
                // åŠ å…¥ç°æœ‰æˆ¿é—´
                const room = availableRooms[0];
                roomId = room.room_id;
                isRoomCreator = false;
                
                console.log('åŠ å…¥ç°æœ‰æˆ¿é—´:', roomId);
                
                // æ›´æ–°æˆ¿é—´ä¿¡æ¯
                const { error: updateError } = await this.supabase
                    .from('game_sessions')
                    .update({
                        player2_id: this.playerId,
                        player2_role: 'electron',
                        updated_at: new Date().toISOString()
                    })
                    .eq('room_id', roomId);
                
                if (updateError) {
                    console.error('æ›´æ–°æˆ¿é—´å¤±è´¥:', updateError);
                    throw updateError;
                }
                
                // è®¾ç½®å¯¹æ‰‹ä¿¡æ¯
                this.opponentId = room.player1_id;
                this.opponentName = 'ç©å®¶_' + (this.opponentId ? this.opponentId.substr(-6) : 'æœªçŸ¥');
                this.playerRole = 'electron'; // åŠ å…¥è€…æ˜¯ç”µå­
                this.mazeSeed = room.maze_seed || Date.now();
                
            } else {
                // åˆ›å»ºæ–°æˆ¿é—´
                roomId = 'room_' + Date.now() + '_' + generateSimpleId();
                isRoomCreator = true;
                
                // ç”Ÿæˆè¿·å®«ç§å­
                this.mazeSeed = Date.now();
                
                console.log('åˆ›å»ºæ–°æˆ¿é—´:', roomId);
                
                // åˆ›å»ºæ¸¸æˆä¼šè¯
                const { error: insertError } = await this.supabase
                    .from('game_sessions')
                    .insert({
                        room_id: roomId,
                        player1_id: this.playerId,
                        player1_role: 'proton', // æˆ¿ä¸»æ€»æ˜¯è´¨å­
                        maze_seed: this.mazeSeed,
                        status: 'waiting',
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    });
                
                if (insertError) {
                    console.error('åˆ›å»ºæˆ¿é—´å¤±è´¥:', insertError);
                    throw insertError;
                }
                
                this.playerRole = 'proton';
            }
            
            this.currentRoom = roomId;
            
            // ä¿å­˜ç©å®¶è§’è‰²åˆ°å…¨å±€å˜é‡
            window.playerRole = this.playerRole;
            if (window.game) {
                window.game.isMultiplayer = true;
                window.game.mazeSeed = this.mazeSeed;
            }
            
            console.log(`âœ… åŒ¹é…æˆåŠŸï¼æˆ¿é—´: ${roomId}, è§’è‰²: ${this.playerRole}, ${isRoomCreator ? 'æˆ¿ä¸»' : 'åŠ å…¥è€…'}`);
            
            // ç«‹å³è¿›å…¥æ¸¸æˆå¤§å…
            setTimeout(() => {
                this.enterLobby();
            }, 500);
            
        } catch (error) {
            console.error('åŒ¹é…å¤±è´¥:', error);
            this.isMatching = false;
            
            // æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
            let errorMessage = 'åŒ¹é…å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
            if (error.message.includes('network') || error.message.includes('fetch')) {
                errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•';
            } else if (error.message.includes('game_sessions')) {
                errorMessage = 'æ•°æ®åº“é”™è¯¯ï¼Œè¯·ç¡®ä¿è¡¨ç»“æ„æ­£ç¡®';
            }
            
            alert(errorMessage);
            switchScene('menuScene');
        }
    },
    
    // æ›´æ–°åŒ¹é…UI
    updateMatchmakingUI(attempts) {
        const timerElement = document.getElementById('matchTimer');
        const progressElement = document.getElementById('matchProgress');
        const statusElement = document.getElementById('matchStatus');
        
        if (timerElement) {
            timerElement.textContent = attempts;
        }
        
        if (progressElement) {
            const progressPercent = Math.min(100, (attempts / 30) * 100);
            progressElement.style.width = `${progressPercent}%`;
        }
        
        if (statusElement) {
            const statuses = [
                "æ‰«æåœ¨çº¿ç©å®¶...",
                "æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ...",
                "ä¼˜åŒ–åŒ¹é…å‚æ•°...",
                "å¯»æ‰¾æœ€ä½³å¯¹æ‰‹...",
                "é‡å­çº ç¼ å»ºç«‹ä¸­..."
            ];
            statusElement.textContent = statuses[attempts % statuses.length];
        }
    },
    
    // å–æ¶ˆåŒ¹é…
    async cancelMatchmaking() {
        try {
            this.isMatching = false;
            
            if (this.currentRoom) {
                // æ¸…ç†æ¸¸æˆä¼šè¯
                const { error } = await this.supabase
                    .from('game_sessions')
                    .delete()
                    .eq('room_id', this.currentRoom);
                
                if (error) {
                    console.error('åˆ é™¤æˆ¿é—´å¤±è´¥:', error);
                }
            }
            
            console.log('âœ… å·²å–æ¶ˆåŒ¹é…');
            switchScene('menuScene');
            
        } catch (error) {
            console.error('å–æ¶ˆåŒ¹é…å¤±è´¥:', error);
            switchScene('menuScene');
        }
    },
    
    // ==================== æ¸¸æˆå¤§å… ====================
    
    // è¿›å…¥æ¸¸æˆå¤§å…
    async enterLobby() {
        console.log('ğŸª è¿›å…¥æ¸¸æˆå¤§å…ï¼Œæˆ¿é—´:', this.currentRoom);
        
        // åˆ‡æ¢åˆ°å¤§å…åœºæ™¯
        switchScene('lobbyScene');
        
        // å¼ºåˆ¶è®¾ç½®ç©å®¶è§’è‰²
        if (window.playerRole !== this.playerRole) {
            window.playerRole = this.playerRole;
            console.log('ğŸ”„ è®¾ç½®ç©å®¶è§’è‰²:', window.playerRole);
        }
        
        // ç«‹å³æ›´æ–°UIæ˜¾ç¤º
        this.updateLobbyUI();
        
        // æ›´æ–°è§’è‰²æ˜¾ç¤º
        this.updateRoleDisplay();
        
        // åˆå§‹åŒ–åŸæœ‰çš„æ¸¸æˆå¤§å…
        if (typeof initializeLobby === 'function') {
            initializeLobby();
        }
        
        // ç›‘å¬å¯¹æ‰‹åŠ å…¥å’Œå‡†å¤‡çŠ¶æ€
        this.setupLobbyListeners();
        
        // è·å–æˆ¿é—´ä¿¡æ¯
        await this.fetchRoomInfo();
    },
    
    // è·å–æˆ¿é—´ä¿¡æ¯
    async fetchRoomInfo() {
        try {
            const { data: session, error } = await this.supabase
                .from('game_sessions')
                .select('*')
                .eq('room_id', this.currentRoom)
                .single();
            
            if (error) {
                console.error('è·å–æˆ¿é—´ä¿¡æ¯å¤±è´¥:', error);
                return;
            }
            
            console.log('æˆ¿é—´è¯¦ç»†ä¿¡æ¯:', session);
            
            // å¦‚æœæœ‰å¯¹æ‰‹ï¼Œæ›´æ–°å¯¹æ‰‹ä¿¡æ¯
            if (session.player2_id && !this.opponentId) {
                this.opponentId = session.player2_id;
                this.opponentName = 'ç©å®¶_' + this.opponentId.substr(-6);
                
                // æ›´æ–°å¯¹æ‰‹UI
                const opponentAction = document.getElementById('opponentAction');
                if (opponentAction) {
                    opponentAction.textContent = 'å¯¹æ‰‹å·²åŠ å…¥ï¼';
                }
                
                console.log('âœ… å¯¹æ‰‹å·²åŠ å…¥:', this.opponentName);
            }
            
            // æ£€æŸ¥å¯¹æ‰‹å‡†å¤‡çŠ¶æ€
            if (session.player1_id === this.playerId) {
                this.opponentReady = session.player2_ready || false;
            } else {
                this.opponentReady = session.player1_ready || false;
            }
            
            this.updateOpponentReadyUI(this.opponentReady);
            
        } catch (error) {
            console.log('è·å–æˆ¿é—´ä¿¡æ¯:', error.message);
        }
    },
    
    // æ›´æ–°å¤§å…UI
    updateLobbyUI() {
        const player1RoleElement = document.getElementById('player1Role');
        const player2RoleElement = document.getElementById('player2Role');
        const player1Card = document.getElementById('player1Card');
        const player2Card = document.getElementById('player2Card');
        const readyBtn = document.getElementById('player1ReadyBtn');
        
        if (player1RoleElement) {
            player1RoleElement.textContent = this.playerRole === 'proton' ? 'è´¨å­ (ä½ )' : 'ç”µå­ (ä½ )';
        }
        
        if (player2RoleElement) {
            player2RoleElement.textContent = this.playerRole === 'proton' ? 'ç”µå­ (å¯¹æ‰‹)' : 'è´¨å­ (å¯¹æ‰‹)';
        }
        
        // æ›´æ–°å¡ç‰‡é¢œè‰²
        if (player1Card) {
            player1Card.style.borderColor = this.playerRole === 'proton' ? 'var(--primary-blue)' : 'var(--primary-red)';
        }
        
        if (player2Card) {
            player2Card.style.borderColor = this.playerRole === 'proton' ? 'var(--primary-red)' : 'var(--primary-blue)';
        }
        
        // æ›´æ–°å‡†å¤‡æŒ‰é’®é¢œè‰²
        if (readyBtn) {
            readyBtn.style.background = this.playerRole === 'proton' ? 'var(--primary-blue)' : 'var(--primary-red)';
            readyBtn.disabled = false;
        }
        
        console.log('ğŸ¨ å¤§å…UIæ›´æ–°å®Œæˆï¼Œç©å®¶è§’è‰²:', this.playerRole);
    },
    
    // æ›´æ–°è§’è‰²æ˜¾ç¤º
    updateRoleDisplay() {
        // æ›´æ–°å…¨å±€ç©å®¶è§’è‰²æ˜¾ç¤º
        const playerNameElement = document.getElementById('playerName');
        const opponentNameElement = document.getElementById('opponentName');
        
        if (playerNameElement) {
            playerNameElement.textContent = this.playerRole === 'proton' ? 'è´¨å­' : 'ç”µå­';
        }
        
        if (opponentNameElement) {
            opponentNameElement.textContent = this.playerRole === 'proton' ? 'ç”µå­' : 'è´¨å­';
        }
        
        // å¼ºåˆ¶æ›´æ–°æ¸¸æˆå¤§å…çš„è§’è‰²æ˜¾ç¤º
        const player1RoleElement = document.getElementById('player1Role');
        const player2RoleElement = document.getElementById('player2Role');
        
        if (player1RoleElement) {
            player1RoleElement.textContent = this.playerRole === 'proton' ? 'è´¨å­ (ä½ )' : 'ç”µå­ (ä½ )';
        }
        
        if (player2RoleElement) {
            player2RoleElement.textContent = this.playerRole === 'proton' ? 'ç”µå­ (å¯¹æ‰‹)' : 'è´¨å­ (å¯¹æ‰‹)';
        }
        
        console.log('ğŸ­ è§’è‰²åˆ†é…å®Œæˆ:', {
            ç©å®¶: this.playerRole,
            å¯¹æ‰‹: this.playerRole === 'proton' ? 'electron' : 'proton'
        });
    },
    
    // è®¾ç½®å¤§å…ç›‘å¬å™¨
    setupLobbyListeners() {
        console.log('è®¾ç½®å¤§å…ç›‘å¬å™¨ï¼Œæˆ¿é—´:', this.currentRoom);
        
        // ç›‘å¬æ¸¸æˆä¼šè¯æ›´æ–°
        this.supabase
            .channel(`lobby:${this.currentRoom}`)
            .on('postgres_changes', {
                event: 'UPDATE',
                schema: 'public',
                table: 'game_sessions',
                filter: `room_id=eq.${this.currentRoom}`
            }, (payload) => {
                console.log('æ¸¸æˆä¼šè¯æ›´æ–°:', payload.new);
                this.handleLobbyUpdate(payload.new);
            })
            .on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'game_actions',
                filter: `room_id=eq.${this.currentRoom}`
            }, (payload) => {
                console.log('æ¸¸æˆåŠ¨ä½œ:', payload.new);
                this.handleGameAction(payload.new);
            })
            .subscribe();
    },
    
    // å¤„ç†å¤§å…æ›´æ–°
    handleLobbyUpdate(sessionData) {
        // æ›´æ–°å¯¹æ‰‹ä¿¡æ¯
        if (sessionData.player2_id && !this.opponentId) {
            this.opponentId = sessionData.player2_id;
            this.opponentName = 'ç©å®¶_' + this.opponentId.substr(-6);
            
            // æ›´æ–°å¯¹æ‰‹UI
            const opponentAction = document.getElementById('opponentAction');
            if (opponentAction) {
                opponentAction.textContent = 'å¯¹æ‰‹å·²åŠ å…¥ï¼';
            }
            
            console.log('âœ… å¯¹æ‰‹åŠ å…¥:', this.opponentName);
        }
        
        // æ›´æ–°å¯¹æ‰‹å‡†å¤‡çŠ¶æ€
        if (sessionData.player1_id === this.playerId) {
            this.opponentReady = sessionData.player2_ready || false;
        } else {
            this.opponentReady = sessionData.player1_ready || false;
        }
        
        this.updateOpponentReadyUI(this.opponentReady);
        
        // æ£€æŸ¥åŒæ–¹æ˜¯å¦éƒ½å‡†å¤‡
        if (sessionData.player1_ready && sessionData.player2_ready) {
            console.log('ğŸš€ åŒæ–¹å‡†å¤‡å®Œæˆï¼Œå¼€å§‹æ¸¸æˆï¼');
            this.startGame();
        }
    },
    
    // å‘é€ç©å®¶å‡†å¤‡çŠ¶æ€
    async sendPlayerReady(isReady) {
        this.isPlayerReady = isReady;
        
        try {
            console.log('å‘é€å‡†å¤‡çŠ¶æ€:', isReady, 'æˆ¿é—´:', this.currentRoom);
            
            // å…ˆè·å–å½“å‰æˆ¿é—´ä¿¡æ¯
            const { data: session, error: fetchError } = await this.supabase
                .from('game_sessions')
                .select('player1_id, player2_id')
                .eq('room_id', this.currentRoom)
                .single();
            
            if (fetchError) {
                console.error('è·å–æˆ¿é—´ä¿¡æ¯å¤±è´¥:', fetchError);
                throw fetchError;
            }
            
            console.log('æˆ¿é—´ä¿¡æ¯:', session);
            
            // ç¡®å®šæ˜¯ç©å®¶1è¿˜æ˜¯ç©å®¶2
            let updateField = '';
            if (session.player1_id === this.playerId) {
                updateField = 'player1_ready';
            } else if (session.player2_id === this.playerId) {
                updateField = 'player2_ready';
            } else {
                throw new Error('ç©å®¶ä¸åœ¨è¯¥æˆ¿é—´ä¸­');
            }
            
            // æ›´æ–°å‡†å¤‡çŠ¶æ€
            const { error: updateError } = await this.supabase
                .from('game_sessions')
                .update({
                    [updateField]: isReady,
                    updated_at: new Date().toISOString()
                })
                .eq('room_id', this.currentRoom);
            
            if (updateError) throw updateError;
            
            console.log('å‡†å¤‡çŠ¶æ€å·²å‘é€:', isReady, 'å­—æ®µ:', updateField);
            
            // åŒæ—¶å‘é€æ¸¸æˆåŠ¨ä½œ
            await this.sendGameAction('player_ready', { ready: isReady });
            
        } catch (error) {
            console.error('å‘é€å‡†å¤‡çŠ¶æ€å¤±è´¥:', error);
            alert('å‡†å¤‡çŠ¶æ€å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    },
    
    // å‘é€æ¸¸æˆåŠ¨ä½œ
    async sendGameAction(actionType, actionData) {
        try {
            const { error } = await this.supabase
                .from('game_actions')
                .insert({
                    room_id: this.currentRoom,
                    player_id: this.playerId,
                    action_type: actionType,
                    action_data: actionData,
                    created_at: new Date().toISOString()
                });
            
            if (error) throw error;
            console.log('æ¸¸æˆåŠ¨ä½œå·²å‘é€:', actionType);
            
        } catch (error) {
            console.error('å‘é€æ¸¸æˆåŠ¨ä½œå¤±è´¥:', error);
        }
    },
    
    // å¤„ç†æ¸¸æˆåŠ¨ä½œ
    handleGameAction(action) {
        // å¿½ç•¥è‡ªå·±çš„åŠ¨ä½œ
        if (action.player_id === this.playerId) return;
        
        console.log('å¤„ç†å¯¹æ‰‹åŠ¨ä½œ:', action.action_type, action.action_data);
        
        switch (action.action_type) {
            case 'player_ready':
                this.opponentReady = action.action_data.ready;
                this.updateOpponentReadyUI(this.opponentReady);
                break;
                
            case 'player_move':
                if (window.game && window.game.players && window.game.players.player2 && window.game.isGameActive) {
                    this.updateOpponentPosition(action.action_data);
                }
                break;
                
            case 'player_shoot':
                if (window.game && window.game.isGameActive) {
                    this.createOpponentProjectile(action.action_data);
                }
                break;
                
            case 'game_start':
                console.log('æ”¶åˆ°æ¸¸æˆå¼€å§‹æŒ‡ä»¤');
                this.startGame();
                break;
                
            case 'game_over':
                console.log('æ”¶åˆ°æ¸¸æˆç»“æŸæŒ‡ä»¤');
                if (window.game && window.game.isGameActive) {
                    window.endGame(action.action_data.winner);
                }
                break;
        }
    },
    
    // æ›´æ–°å¯¹æ‰‹å‡†å¤‡UI
    updateOpponentReadyUI(isReady) {
        const statusDot = document.getElementById('player2StatusDot');
        const statusText = document.getElementById('player2StatusText');
        const actionText = document.getElementById('opponentAction');
        
        if (statusDot && statusText && actionText) {
            if (isReady) {
                statusDot.style.background = '#10b981';
                statusText.textContent = 'å·²å‡†å¤‡';
                actionText.textContent = 'å¯¹æ‰‹å·²å‡†å¤‡ï¼';
            } else {
                statusDot.style.background = '#64748b';
                statusText.textContent = 'æœªå‡†å¤‡';
                actionText.textContent = 'ç­‰å¾…å¯¹æ‰‹å‡†å¤‡...';
            }
        }
    },
    
    // ==================== æ¸¸æˆå¼€å§‹ ====================
    
    async startGame() {
        console.log('ğŸ® å¼€å§‹å¤šäººæ¸¸æˆ');
        
        try {
            // æ›´æ–°æ¸¸æˆä¼šè¯çŠ¶æ€
            const { error: updateError } = await this.supabase
                .from('game_sessions')
                .update({ 
                    status: 'active',
                    started_at: new Date().toISOString()
                })
                .eq('room_id', this.currentRoom);
            
            if (updateError) throw updateError;
            
            // å‘é€æ¸¸æˆå¼€å§‹åŠ¨ä½œ
            await this.sendGameAction('game_start', { time: Date.now() });
            
            // åˆ‡æ¢åˆ°åŠ è½½åœºæ™¯
            switchScene('loadingScene');
            
            // æ¨¡æ‹ŸåŠ è½½
            setTimeout(() => {
                // è®¾ç½®æ¸¸æˆä¸ºå¤šäººæ¨¡å¼
                if (window.game) {
                    window.game.isMultiplayer = true;
                    window.game.isConnectedToOpponent = true;
                }
                
                // åˆå§‹åŒ–æ¸¸æˆ
                if (typeof initializeGame === 'function') {
                    initializeGame();
                }
                
                // å¼€å§‹æ¸¸æˆåŒæ­¥
                this.startGameSync();
                
            }, 1500);
            
        } catch (error) {
            console.error('å¼€å§‹æ¸¸æˆå¤±è´¥:', error);
        }
    },
    
    // ==================== æ¸¸æˆåŒæ­¥ ====================
    
    startGameSync() {
        console.log('ğŸ”„ å¼€å§‹æ¸¸æˆçŠ¶æ€åŒæ­¥');
        
        // ç›‘å¬æ¸¸æˆåŠ¨ä½œ
        this.setupGameListeners();
        
        // å¼€å§‹å‘é€ç©å®¶åŠ¨ä½œ
        this.startSendingPlayerActions();
    },
    
    setupGameListeners() {
        console.log('è®¾ç½®æ¸¸æˆç›‘å¬å™¨ï¼Œæˆ¿é—´:', this.currentRoom);
        
        // ç›‘å¬æ¸¸æˆåŠ¨ä½œ
        this.supabase
            .channel(`game:${this.currentRoom}`)
            .on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'game_actions',
                filter: `room_id=eq.${this.currentRoom}`
            }, (payload) => {
                this.handleGameAction(payload.new);
            })
            .subscribe();
    },
    
    startSendingPlayerActions() {
        console.log('ğŸ“¤ å¼€å§‹å‘é€ç©å®¶åŠ¨ä½œ');
        
        // å®šæœŸå‘é€ä½ç½®æ›´æ–°
        let lastPositionUpdate = 0;
        const positionInterval = setInterval(() => {
            if (!window.game || !window.game.isGameActive) {
                clearInterval(positionInterval);
                return;
            }
            
            const player = window.game.players?.player1;
            if (player && player.isLocalPlayer) {
                const currentTime = Date.now();
                
                // æ¯200mså‘é€ä¸€æ¬¡ä½ç½®ï¼Œæˆ–è€…å½“ä½ç½®å˜åŒ–è¾ƒå¤§æ—¶
                if (currentTime - lastPositionUpdate > 200) {
                    this.sendPlayerPosition(player);
                    lastPositionUpdate = currentTime;
                }
            }
        }, 200);
    },
    
    // å‘é€ç©å®¶ä½ç½®
    async sendPlayerPosition(player) {
        await this.sendGameAction('player_move', {
            x: player.x,
            y: player.y,
            direction: player.direction,
            timestamp: Date.now()
        });
    },
    
    // å‘é€å°„å‡»åŠ¨ä½œ
    async sendShootAction(player) {
        await this.sendGameAction('player_shoot', {
            x: player.x,
            y: player.y,
            direction: player.direction,
            timestamp: Date.now()
        });
    },
    
    // å‘é€å‡»ä¸­äº‹ä»¶
    async sendHitAction(target, projectile) {
        await this.sendGameAction('player_hit', {
            target: target,
            damage: 25,
            projectile_id: projectile.id,
            timestamp: Date.now()
        });
    },
    
    // å‘é€æ¸¸æˆç»“æŸ
    async sendGameOver(winner) {
        await this.sendGameAction('game_over', {
            winner: winner,
            timestamp: Date.now()
        });
    },
    
    // ==================== å¤„ç†å¯¹æ‰‹åŠ¨ä½œ ====================
    
    updateOpponentPosition(positionData) {
        if (!window.game || !window.game.players || !window.game.players.player2 || !window.game.isGameActive) return;
        
        // æ’å€¼å¹³æ»‘ç§»åŠ¨
        const targetX = positionData.x;
        const targetY = positionData.y;
        
        // ç®€å•çš„æ’å€¼
        window.game.players.player2.x += (targetX - window.game.players.player2.x) * 0.3;
        window.game.players.player2.y += (targetY - window.game.players.player2.y) * 0.3;
        window.game.players.player2.direction = positionData.direction;
        
        // æ ‡è®°ä¸ºçœŸäººå¯¹æ‰‹ï¼Œä¸æ˜¯AI
        window.game.players.player2.isAI = false;
        window.game.players.player2.isLocalPlayer = false;
    },
    
    createOpponentProjectile(projectileData) {
        if (!window.game || !window.game.isGameActive) return;
        
        // åˆ›å»ºå¯¹æ‰‹çš„å­å¼¹
        const projectile = {
            id: Date.now() + Math.random(),
            x: projectileData.x,
            y: projectileData.y,
            radius: 6,
            color: this.playerRole === 'proton' ? '#ef4444' : '#3b82f6',
            speed: 8,
            direction: projectileData.direction,
            dx: Math.cos(projectileData.direction) * 8,
            dy: Math.sin(projectileData.direction) * 8,
            owner: 'player2',
            shooterId: 'player2',
            bounceCount: 3,
            lifeTime: 5000,
            active: true
        };
        
        window.game.projectiles.push(projectile);
        console.log('ğŸ¯ åˆ›å»ºå¯¹æ‰‹å­å¼¹');
    },
    
    // ==================== å¿ƒè·³ç³»ç»Ÿï¼ˆç®€åŒ–ç‰ˆï¼‰ ====================
    
    startSimpleHeartbeat() {
        console.log('ğŸ’“ å¯åŠ¨ç®€åŒ–å¿ƒè·³');
        
        this.heartbeatInterval = setInterval(async () => {
            try {
                // ç®€å•çš„å¿ƒè·³ï¼šæ›´æ–°æœ€ååœ¨çº¿æ—¶é—´
                await this.supabase
                    .from('profiles')
                    .update({ 
                        last_online: new Date().toISOString(),
                        client_id: this.clientId
                    })
                    .eq('id', this.playerId);
                
                this.isConnected = true;
                
            } catch (error) {
                console.log('å¿ƒè·³å¤±è´¥:', error.message);
                this.isConnected = false;
            }
        }, 30000); // æ¯30ç§’ä¸€æ¬¡
    },
    
    // ==================== å·¥å…·å‡½æ•° ====================
    
    // æ¸…ç†èµ„æº
    cleanup() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
        
        if (this.supabase) {
            this.supabase.removeAllChannels();
        }
        
        this.isConnected = false;
        this.isInitialized = false;
        this.initializationPromise = null;
    }
};

// å…¨å±€æš´éœ²
window.MultiplayerGame = MultiplayerGame;

// ==================== æµ‹è¯•è¿æ¥å‡½æ•° ====================
async function testMultiplayerConnection() {
    try {
        if (!window.MultiplayerGame.supabase) {
            await window.MultiplayerGame.init();
        }
        
        // æµ‹è¯•è¿æ¥
        const { data, error } = await window.MultiplayerGame.supabase
            .from('profiles')
            .select('count')
            .limit(1);
        
        if (error) throw error;
        
        alert('âœ… å¤šäººæ¸¸æˆè¿æ¥æµ‹è¯•æˆåŠŸï¼\nå¯ä»¥å¼€å§‹åŒ¹é…çœŸäººç©å®¶äº†ã€‚');
        
    } catch (error) {
        alert('âŒ è¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message);
    }
}

// ==================== é‡å†™åŸæœ‰çš„togglePlayerReadyä»¥æ”¯æŒå¤šäººæ¸¸æˆ ====================
const originalTogglePlayerReady = window.togglePlayerReady;
window.togglePlayerReady = function() {
    // æ£€æŸ¥æ˜¯å¦åœ¨å¤šäººæ¸¸æˆå¤§å…
    if (window.MultiplayerGame && window.MultiplayerGame.currentRoom) {
        const readyBtn = document.getElementById('player1ReadyBtn');
        if (!readyBtn) return;
        
        const isReady = readyBtn.textContent === 'ç‚¹å‡»å‡†å¤‡';
        
        if (isReady) {
            readyBtn.textContent = 'å–æ¶ˆå‡†å¤‡';
            readyBtn.style.background = '#64748b';
            
            // å‘é€å‡†å¤‡çŠ¶æ€
            window.MultiplayerGame.sendPlayerReady(true);
        } else {
            readyBtn.textContent = 'ç‚¹å‡»å‡†å¤‡';
            readyBtn.style.background = window.playerRole === 'proton' ? 'var(--primary-blue)' : 'var(--primary-red)';
            
            // å‘é€å–æ¶ˆå‡†å¤‡çŠ¶æ€
            window.MultiplayerGame.sendPlayerReady(false);
        }
    } else {
        // å•äººæ¸¸æˆæ¨¡å¼ï¼Œè°ƒç”¨åŸæœ‰å‡½æ•°
        originalTogglePlayerReady();
    }
};

// ==================== ä¿®å¤initializeLobbyå‡½æ•° ====================
const originalInitializeLobby = window.initializeLobby;
window.initializeLobby = function() {
    if (originalInitializeLobby) {
        originalInitializeLobby();
    }
    
    // å¼ºåˆ¶è®¾ç½®ç©å®¶è§’è‰²
    if (window.MultiplayerGame && window.MultiplayerGame.playerRole) {
        window.playerRole = window.MultiplayerGame.playerRole;
        console.log('ğŸ”„ åœ¨initializeLobbyä¸­è®¾ç½®ç©å®¶è§’è‰²:', window.playerRole);
    }
    
    // æ›´æ–°å‡†å¤‡æŒ‰é’®é¢œè‰²
    const readyBtn = document.getElementById('player1ReadyBtn');
    if (readyBtn && window.playerRole) {
        readyBtn.style.background = window.playerRole === 'proton' ? 'var(--primary-blue)' : 'var(--primary-red)';
    }
};

// ==================== é¡µé¢åŠ è½½åˆå§‹åŒ– ====================
document.addEventListener('DOMContentLoaded', function() {
    console.log('âœ… DOMåŠ è½½å®Œæˆ');
    
    // æ¸…ç†æ—§çš„ID
    cleanupOldIds();
    
    // åˆå§‹åŒ– MultiplayerGame å¯¹è±¡åˆ°å…¨å±€
    if (!window.MultiplayerGame) {
        window.MultiplayerGame = MultiplayerGame;
    }
    
    // æ¨¡æ‹Ÿåœ¨çº¿ç©å®¶æ•°æ›´æ–°
    setInterval(() => {
        const onlineCount = document.getElementById('onlineCount');
        const dailyMatches = document.getElementById('dailyMatches');
        const matchSpeed = document.getElementById('matchSpeed');
        
        if (onlineCount) {
            const current = parseInt(onlineCount.textContent);
            const change = Math.floor(Math.random() * 11) - 5;
            onlineCount.textContent = Math.max(100, current + change);
        }
        
        if (dailyMatches) {
            const current = parseInt(dailyMatches.textContent);
            dailyMatches.textContent = current + Math.floor(Math.random() * 10);
        }
        
    }, 5000);
    
    console.log('ğŸ® æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼Œå¯ä»¥å¼€å§‹æ¸¸æˆï¼');
});

// ==================== çª—å£å¤§å°å˜åŒ–å¤„ç† ====================
window.addEventListener('resize', function() {
    if (game.canvas && game.isGameActive) {
        resizeGameCanvas();
        initializeCamera();
    }
});

// ==================== é¡µé¢å¯è§æ€§å¤„ç† ====================
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        console.log('â¸ï¸ é¡µé¢éšè—ï¼Œæš‚åœæ¸¸æˆæ›´æ–°');
        // å¯ä»¥åœ¨è¿™é‡Œæš‚åœæ¸¸æˆå¾ªç¯
    } else {
        console.log('â–¶ï¸ é¡µé¢æ¢å¤ï¼Œç»§ç»­æ¸¸æˆ');
        // æ¢å¤æ¸¸æˆå¾ªç¯
    }
});

// ==================== é˜²æ­¢æµè§ˆå™¨åé€€ ====================
history.pushState(null, null, location.href);
window.onpopstate = function(event) {
    history.go(1);
};
</script>
</body>
</html>